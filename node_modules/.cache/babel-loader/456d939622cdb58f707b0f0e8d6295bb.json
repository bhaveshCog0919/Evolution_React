{"ast":null,"code":"'use strict'; // Helper class to rewrite nodes with specific mime type\n\nvar _classCallCheck = require(\"/Users/bhavik/Downloads/Cognisun/Evolution/Evolution_React/evolution_new/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/bhavik/Downloads/Cognisun/Evolution/Evolution_React/evolution_new/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/bhavik/Downloads/Cognisun/Evolution/Evolution_React/evolution_new/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/bhavik/Downloads/Cognisun/Evolution/Evolution_React/evolution_new/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar Transform = require('stream').Transform;\n\nvar FlowedDecoder = require('./flowed-decoder');\n/**\n * NodeRewriter Transform stream. Updates content for all nodes with specified mime type\n *\n * @constructor\n * @param {String} mimeType Define the Mime-Type to look for\n * @param {Function} rewriteAction Function to run with the node content\n */\n\n\nvar NodeRewriter = /*#__PURE__*/function (_Transform) {\n  _inherits(NodeRewriter, _Transform);\n\n  var _super = _createSuper(NodeRewriter);\n\n  function NodeRewriter(filterFunc, rewriteAction) {\n    var _this;\n\n    _classCallCheck(this, NodeRewriter);\n\n    var options = {\n      readableObjectMode: true,\n      writableObjectMode: true\n    };\n    _this = _super.call(this, options);\n    _this.filterFunc = filterFunc;\n    _this.rewriteAction = rewriteAction;\n    _this.decoder = false;\n    _this.encoder = false;\n    _this.continue = false;\n    return _this;\n  }\n\n  _createClass(NodeRewriter, [{\n    key: \"_transform\",\n    value: function _transform(data, encoding, callback) {\n      this.processIncoming(data, callback);\n    }\n  }, {\n    key: \"_flush\",\n    value: function _flush(callback) {\n      if (this.decoder) {\n        // emit an empty node just in case there is pending data to end\n        return this.processIncoming({\n          type: 'none'\n        }, callback);\n      }\n\n      return callback();\n    }\n  }, {\n    key: \"processIncoming\",\n    value: function processIncoming(data, callback) {\n      var _this2 = this;\n\n      if (this.decoder && data.type === 'body') {\n        // data to parse\n        if (!this.decoder.write(data.value)) {\n          return this.decoder.once('drain', callback);\n        } else {\n          return callback();\n        }\n      } else if (this.decoder && data.type !== 'body') {\n        // stop decoding.\n        // we can not process the current data chunk as we need to wait until\n        // the parsed data is completely processed, so we store a reference to the\n        // continue callback\n        this.continue = function () {\n          _this2.continue = false;\n          _this2.decoder = false;\n          _this2.encoder = false;\n\n          _this2.processIncoming(data, callback);\n        };\n\n        return this.decoder.end();\n      } else if (data.type === 'node' && this.filterFunc(data)) {\n        // found matching node, create new handler\n        this.emit('node', this.createDecodePair(data));\n      } else if (this.readable && data.type !== 'none') {\n        // we don't care about this data, just pass it over to the joiner\n        this.push(data);\n      }\n\n      callback();\n    }\n  }, {\n    key: \"createDecodePair\",\n    value: function createDecodePair(node) {\n      var _this3 = this;\n\n      this.decoder = node.getDecoder();\n\n      if (['base64', 'quoted-printable'].includes(node.encoding)) {\n        this.encoder = node.getEncoder();\n      } else {\n        this.encoder = node.getEncoder('quoted-printable');\n      }\n\n      var lastByte = false;\n      var decoder = this.decoder;\n      var encoder = this.encoder;\n      var firstChunk = true;\n      decoder.$reading = false;\n\n      var readFromEncoder = function readFromEncoder() {\n        decoder.$reading = true;\n        var data = encoder.read();\n\n        if (data === null) {\n          decoder.$reading = false;\n          return;\n        }\n\n        if (firstChunk) {\n          firstChunk = false;\n\n          if (_this3.readable) {\n            _this3.push(node);\n\n            if (node.type === 'body') {\n              lastByte = node.value && node.value.length && node.value[node.value.length - 1];\n            }\n          }\n        }\n\n        var writeMore = true;\n\n        if (_this3.readable) {\n          writeMore = _this3.push({\n            node: node,\n            type: 'body',\n            value: data\n          });\n          lastByte = data && data.length && data[data.length - 1];\n        }\n\n        if (writeMore) {\n          return setImmediate(readFromEncoder);\n        } else {\n          encoder.pause(); // no idea how to catch drain? use timeout for now as poor man's substitute\n          // this.once('drain', () => encoder.resume());\n\n          setTimeout(function () {\n            encoder.resume();\n            setImmediate(readFromEncoder);\n          }, 100);\n        }\n      };\n\n      encoder.on('readable', function () {\n        if (!decoder.$reading) {\n          return readFromEncoder();\n        }\n      });\n      encoder.on('end', function () {\n        if (firstChunk) {\n          firstChunk = false;\n\n          if (_this3.readable) {\n            _this3.push(node);\n\n            if (node.type === 'body') {\n              lastByte = node.value && node.value.length && node.value[node.value.length - 1];\n            }\n          }\n        }\n\n        if (lastByte !== 0x0a) {\n          // make sure there is a terminating line break\n          _this3.push({\n            node: node,\n            type: 'body',\n            value: Buffer.from([0x0a])\n          });\n        }\n\n        if (_this3.continue) {\n          return _this3.continue();\n        }\n      });\n\n      if (/^text\\//.test(node.contentType) && node.flowed) {\n        // text/plain; format=flowed is a special case\n        var flowDecoder = decoder;\n        decoder = new FlowedDecoder({\n          delSp: node.delSp,\n          encoding: node.encoding\n        });\n        flowDecoder.on('error', function (err) {\n          decoder.emit('error', err);\n        });\n        flowDecoder.pipe(decoder); // we don't know what kind of data we are going to get, does it comply with the\n        // requirements of format=flowed, so we just cancel it\n\n        node.flowed = false;\n        node.delSp = false;\n        node.setContentType();\n      }\n\n      return {\n        node: node,\n        decoder: decoder,\n        encoder: encoder\n      };\n    }\n  }]);\n\n  return NodeRewriter;\n}(Transform);\n\nmodule.exports = NodeRewriter;","map":null,"metadata":{},"sourceType":"script"}