{"ast":null,"code":"'use strict';\n\nvar _defineProperty = require(\"/Users/bhavik/Downloads/Cognisun/Evolution/Evolution_React/evolution_new/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _classCallCheck = require(\"/Users/bhavik/Downloads/Cognisun/Evolution/Evolution_React/evolution_new/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/bhavik/Downloads/Cognisun/Evolution/Evolution_React/evolution_new/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/bhavik/Downloads/Cognisun/Evolution/Evolution_React/evolution_new/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/bhavik/Downloads/Cognisun/Evolution/Evolution_React/evolution_new/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar mailsplit = require('mailsplit');\n\nvar libmime = require('libmime');\n\nvar addressparser = require('nodemailer/lib/addressparser');\n\nvar Transform = require('stream').Transform;\n\nvar Splitter = mailsplit.Splitter;\n\nvar punycode = require('punycode');\n\nvar FlowedDecoder = require('mailsplit/lib/flowed-decoder');\n\nvar StreamHash = require('./stream-hash');\n\nvar iconv = require('iconv-lite');\n\nvar htmlToText = require('html-to-text');\n\nvar he = require('he');\n\nvar linkify = require('linkify-it')();\n\nvar tlds = require('tlds');\n\nvar encodingJapanese = require('encoding-japanese');\n\nlinkify.tlds(tlds) // Reload with full tlds list\n.tlds('onion', true) // Add unofficial `.onion` domain\n.add('git:', 'http:') // Add `git:` ptotocol as \"alias\"\n.add('ftp:', null) // Disable `ftp:` ptotocol\n.set({\n  fuzzyIP: true,\n  fuzzyLink: true,\n  fuzzyEmail: true\n}); // twitter linkifier from\n// https://github.com/markdown-it/linkify-it#example-2-add-twitter-mentions-handler\n\nlinkify.add('@', {\n  validate: function validate(text, pos, self) {\n    var tail = text.slice(pos);\n\n    if (!self.re.twitter) {\n      self.re.twitter = new RegExp('^([a-zA-Z0-9_]){1,15}(?!_)(?=$|' + self.re.src_ZPCc + ')');\n    }\n\n    if (self.re.twitter.test(tail)) {\n      // Linkifier allows punctuation chars before prefix,\n      // but we additionally disable `@` (\"@@mention\" is invalid)\n      if (pos >= 2 && tail[pos - 2] === '@') {\n        return false;\n      }\n\n      return tail.match(self.re.twitter)[0].length;\n    }\n\n    return 0;\n  },\n  normalize: function normalize(match) {\n    match.url = 'https://twitter.com/' + match.url.replace(/^@/, '');\n  }\n});\n\nvar IconvDecoder = /*#__PURE__*/function (_Transform) {\n  _inherits(IconvDecoder, _Transform);\n\n  var _super = _createSuper(IconvDecoder);\n\n  function IconvDecoder(Iconv, charset) {\n    var _this;\n\n    _classCallCheck(this, IconvDecoder);\n\n    _this = _super.call(this); // Iconv throws error on ks_c_5601-1987 when it is mapped to EUC-KR\n    // https://github.com/bnoordhuis/node-iconv/issues/169\n\n    if (charset.toLowerCase() === 'ks_c_5601-1987') {\n      charset = 'CP949';\n    }\n\n    _this.stream = new Iconv(charset, 'UTF-8//TRANSLIT//IGNORE');\n    _this.inputEnded = false;\n    _this.endCb = false;\n\n    _this.stream.on('error', function (err) {\n      return _this.emit('error', err);\n    });\n\n    _this.stream.on('data', function (chunk) {\n      return _this.push(chunk);\n    });\n\n    _this.stream.on('end', function () {\n      _this.inputEnded = true;\n\n      if (typeof _this.endCb === 'function') {\n        _this.endCb();\n      }\n    });\n\n    return _this;\n  }\n\n  _createClass(IconvDecoder, [{\n    key: \"_transform\",\n    value: function _transform(chunk, encoding, done) {\n      this.stream.write(chunk);\n      done();\n    }\n  }, {\n    key: \"_flush\",\n    value: function _flush(done) {\n      this.endCb = done;\n      this.stream.end();\n    }\n  }]);\n\n  return IconvDecoder;\n}(Transform);\n\nvar JPDecoder = /*#__PURE__*/function (_Transform2) {\n  _inherits(JPDecoder, _Transform2);\n\n  var _super2 = _createSuper(JPDecoder);\n\n  function JPDecoder(charset) {\n    var _this2;\n\n    _classCallCheck(this, JPDecoder);\n\n    _this2 = _super2.call(this);\n    _this2.charset = charset;\n    _this2.chunks = [];\n    _this2.chunklen = 0;\n    return _this2;\n  }\n\n  _createClass(JPDecoder, [{\n    key: \"_transform\",\n    value: function _transform(chunk, encoding, done) {\n      if (typeof chunk === 'string') {\n        chunk = Buffer.from(chunk, encoding);\n      }\n\n      this.chunks.push(chunk);\n      this.chunklen += chunk.length;\n      done();\n    }\n  }, {\n    key: \"_flush\",\n    value: function _flush(done) {\n      var input = Buffer.concat(this.chunks, this.chunklen);\n\n      try {\n        var output = encodingJapanese.convert(input, {\n          to: 'UNICODE',\n          // to_encoding\n          from: this.charset,\n          // from_encoding\n          type: 'string'\n        });\n\n        if (typeof output === 'string') {\n          output = Buffer.from(output);\n        }\n\n        this.push(output);\n      } catch (err) {\n        // keep as is on errors\n        this.push(input);\n      }\n\n      done();\n    }\n  }]);\n\n  return JPDecoder;\n}(Transform);\n\nvar MailParser = /*#__PURE__*/function (_Transform3) {\n  _inherits(MailParser, _Transform3);\n\n  var _super3 = _createSuper(MailParser);\n\n  function MailParser(config) {\n    var _this3;\n\n    _classCallCheck(this, MailParser);\n\n    _this3 = _super3.call(this, {\n      readableObjectMode: true,\n      writableObjectMode: false\n    });\n    _this3.options = config || {};\n    _this3.splitter = new Splitter(config);\n    _this3.finished = false;\n    _this3.waitingEnd = false;\n    _this3.headers = false;\n    _this3.headerLines = false;\n    _this3.endReceived = false;\n    _this3.reading = false;\n    _this3.errored = false;\n    _this3.tree = false;\n    _this3.curnode = false;\n    _this3.waitUntilAttachmentEnd = false;\n    _this3.attachmentCallback = false;\n    _this3.hasHtml = false;\n    _this3.hasText = false;\n    _this3.text = false;\n    _this3.html = false;\n    _this3.textAsHtml = false;\n    _this3.attachmentList = [];\n    _this3.boundaries = [];\n    _this3.decoder = _this3.getDecoder();\n\n    _this3.splitter.on('readable', function () {\n      if (_this3.reading) {\n        return false;\n      }\n\n      _this3.readData();\n    });\n\n    _this3.splitter.on('end', function () {\n      _this3.endReceived = true;\n\n      if (!_this3.reading) {\n        _this3.endStream();\n      }\n    });\n\n    _this3.splitter.on('error', function (err) {\n      _this3.errored = true;\n\n      if (typeof _this3.waitingEnd === 'function') {\n        return _this3.waitingEnd(err);\n      }\n\n      _this3.emit('error', err);\n    });\n\n    _this3.libmime = new libmime.Libmime({\n      Iconv: _this3.options.Iconv\n    });\n    return _this3;\n  }\n\n  _createClass(MailParser, [{\n    key: \"getDecoder\",\n    value: function getDecoder() {\n      if (this.options.Iconv) {\n        var Iconv = this.options.Iconv; // create wrapper\n\n        return {\n          decodeStream: function decodeStream(charset) {\n            return new IconvDecoder(Iconv, charset);\n          }\n        };\n      } else {\n        return {\n          decodeStream: function decodeStream(charset) {\n            charset = (charset || 'ascii').toString().trim().toLowerCase();\n\n            if (/^jis|^iso-?2022-?jp|^EUCJP/i.test(charset)) {\n              // special case not supported by iconv-lite\n              return new JPDecoder(charset);\n            }\n\n            return iconv.decodeStream(charset);\n          }\n        };\n      }\n    }\n  }, {\n    key: \"readData\",\n    value: function readData() {\n      var _this4 = this;\n\n      if (this.errored) {\n        return false;\n      }\n\n      this.reading = true;\n      var data = this.splitter.read();\n\n      if (data === null) {\n        this.reading = false;\n\n        if (this.endReceived) {\n          this.endStream();\n        }\n\n        return;\n      }\n\n      this.processChunk(data, function (err) {\n        if (err) {\n          if (typeof _this4.waitingEnd === 'function') {\n            return _this4.waitingEnd(err);\n          }\n\n          return _this4.emit('error', err);\n        }\n\n        setImmediate(function () {\n          return _this4.readData();\n        });\n      });\n    }\n  }, {\n    key: \"endStream\",\n    value: function endStream() {\n      this.finished = true;\n\n      if (this.curnode && this.curnode.decoder) {\n        this.curnode.decoder.end();\n      }\n\n      if (typeof this.waitingEnd === 'function') {\n        this.waitingEnd();\n      }\n    }\n  }, {\n    key: \"_transform\",\n    value: function _transform(chunk, encoding, done) {\n      if (!chunk || !chunk.length) {\n        return done();\n      }\n\n      if (this.splitter.write(chunk) === false) {\n        return this.splitter.once('drain', function () {\n          done();\n        });\n      } else {\n        return done();\n      }\n    }\n  }, {\n    key: \"_flush\",\n    value: function _flush(done) {\n      var _this5 = this;\n\n      setImmediate(function () {\n        return _this5.splitter.end();\n      });\n\n      if (this.finished) {\n        return this.cleanup(done);\n      }\n\n      this.waitingEnd = function () {\n        _this5.cleanup(function () {\n          done();\n        });\n      };\n    }\n  }, {\n    key: \"cleanup\",\n    value: function cleanup(done) {\n      var _this6 = this;\n\n      var finish = function finish() {\n        var t = _this6.getTextContent();\n\n        _this6.push(t);\n\n        done();\n      };\n\n      if (this.curnode && this.curnode.decoder && this.curnode.decoder.readable && !this.decoderEnded) {\n        (this.curnode.contentStream || this.curnode.decoder).once('end', function () {\n          finish();\n        });\n        this.curnode.decoder.end();\n      } else {\n        setImmediate(function () {\n          finish();\n        });\n      }\n    }\n  }, {\n    key: \"processHeaders\",\n    value: function processHeaders(lines) {\n      var _this7 = this;\n\n      var headers = new Map();\n      (lines || []).forEach(function (line) {\n        var key = line.key;\n        var value = ((_this7.libmime.decodeHeader(line.line) || {}).value || '').toString().trim();\n        value = Buffer.from(value, 'binary').toString();\n\n        switch (key) {\n          case 'content-type':\n          case 'content-disposition':\n          case 'dkim-signature':\n            value = _this7.libmime.parseHeaderValue(value);\n\n            if (value.value) {\n              value.value = _this7.libmime.decodeWords(value.value);\n            }\n\n            Object.keys(value && value.params || {}).forEach(function (key) {\n              try {\n                value.params[key] = _this7.libmime.decodeWords(value.params[key]);\n              } catch (E) {// ignore, keep as is\n              }\n            });\n            break;\n\n          case 'date':\n            value = new Date(value);\n\n            if (!value || value.toString() === 'Invalid Date' || !value.getTime()) {\n              // date parsing failed :S\n              value = new Date();\n            }\n\n            break;\n\n          case 'subject':\n            try {\n              value = _this7.libmime.decodeWords(value);\n            } catch (E) {// ignore, keep as is\n            }\n\n            break;\n\n          case 'references':\n            try {\n              value = _this7.libmime.decodeWords(value);\n            } catch (E) {// ignore\n            }\n\n            value = value.split(/\\s+/).map(_this7.ensureMessageIDFormat);\n            break;\n\n          case 'message-id':\n          case 'in-reply-to':\n            try {\n              value = _this7.libmime.decodeWords(value);\n            } catch (E) {// ignore\n            }\n\n            value = _this7.ensureMessageIDFormat(value);\n            break;\n\n          case 'priority':\n          case 'x-priority':\n          case 'x-msmail-priority':\n          case 'importance':\n            key = 'priority';\n            value = _this7.parsePriority(value);\n            break;\n\n          case 'from':\n          case 'to':\n          case 'cc':\n          case 'bcc':\n          case 'sender':\n          case 'reply-to':\n          case 'delivered-to':\n          case 'return-path':\n            value = addressparser(value);\n\n            _this7.decodeAddresses(value);\n\n            value = {\n              value: value,\n              html: _this7.getAddressesHTML(value),\n              text: _this7.getAddressesText(value)\n            };\n            break;\n        } // handle list-* keys\n\n\n        if (key.substr(0, 5) === 'list-') {\n          value = _this7.parseListHeader(key.substr(5), value);\n          key = 'list';\n        }\n\n        if (value) {\n          if (!headers.has(key)) {\n            headers.set(key, [].concat(value || []));\n          } else if (Array.isArray(value)) {\n            headers.set(key, headers.get(key).concat(value));\n          } else {\n            headers.get(key).push(value);\n          }\n        }\n      }); // keep only the first value\n\n      var singleKeys = ['message-id', 'content-id', 'from', 'sender', 'in-reply-to', 'reply-to', 'subject', 'date', 'content-disposition', 'content-type', 'content-transfer-encoding', 'priority', 'mime-version', 'content-description', 'precedence', 'errors-to'];\n      headers.forEach(function (value, key) {\n        if (Array.isArray(value)) {\n          if (singleKeys.includes(key) && value.length) {\n            headers.set(key, value[value.length - 1]);\n          } else if (value.length === 1) {\n            headers.set(key, value[0]);\n          }\n        }\n\n        if (key === 'list') {\n          // normalize List-* headers\n          var listValue = {};\n          [].concat(value || []).forEach(function (val) {\n            Object.keys(val || {}).forEach(function (listKey) {\n              listValue[listKey] = val[listKey];\n            });\n          });\n          headers.set(key, listValue);\n        }\n      });\n      return headers;\n    }\n  }, {\n    key: \"parseListHeader\",\n    value: function parseListHeader(key, value) {\n      var addresses = addressparser(value);\n      var response = {};\n      var data = addresses.map(function (address) {\n        if (/^https?:/i.test(address.name)) {\n          response.url = address.name;\n        } else if (address.name) {\n          response.name = address.name;\n        }\n\n        if (/^mailto:/.test(address.address)) {\n          response.mail = address.address.substr(7);\n        } else if (address.address && address.address.indexOf('@') < 0) {\n          response.id = address.address;\n        } else if (address.address) {\n          response.mail = address.address;\n        }\n\n        if (Object.keys(response).length) {\n          return response;\n        }\n\n        return false;\n      }).filter(function (address) {\n        return address;\n      });\n\n      if (data.length) {\n        return _defineProperty({}, key, response);\n      }\n\n      return false;\n    }\n  }, {\n    key: \"parsePriority\",\n    value: function parsePriority(value) {\n      value = value.toLowerCase().trim();\n\n      if (!isNaN(parseInt(value, 10))) {\n        // support \"X-Priority: 1 (Highest)\"\n        value = parseInt(value, 10) || 0;\n\n        if (value === 3) {\n          return 'normal';\n        } else if (value > 3) {\n          return 'low';\n        } else {\n          return 'high';\n        }\n      } else {\n        switch (value) {\n          case 'non-urgent':\n          case 'low':\n            return 'low';\n\n          case 'urgent':\n          case 'high':\n            return 'high';\n        }\n      }\n\n      return 'normal';\n    }\n  }, {\n    key: \"ensureMessageIDFormat\",\n    value: function ensureMessageIDFormat(value) {\n      if (!value.length) {\n        return false;\n      }\n\n      if (value.charAt(0) !== '<') {\n        value = '<' + value;\n      }\n\n      if (value.charAt(value.length - 1) !== '>') {\n        value += '>';\n      }\n\n      return value;\n    }\n  }, {\n    key: \"decodeAddresses\",\n    value: function decodeAddresses(addresses) {\n      for (var i = 0; i < addresses.length; i++) {\n        var address = addresses[i];\n        address.name = (address.name || '').toString().trim();\n\n        if (!address.address && /^(=\\?([^?]+)\\?[Bb]\\?[^?]*\\?=)(\\s*=\\?([^?]+)\\?[Bb]\\?[^?]*\\?=)*$/.test(address.name)) {\n          var parsed = addressparser(this.libmime.decodeWords(address.name));\n\n          if (parsed.length) {\n            parsed.forEach(function (entry) {\n              return addresses.push(entry);\n            });\n          } // remove current element\n\n\n          addresses.splice(i, 1);\n          i--;\n          continue;\n        }\n\n        if (address.name) {\n          try {\n            address.name = this.libmime.decodeWords(address.name);\n          } catch (E) {//ignore, keep as is\n          }\n        }\n\n        if (/@xn--/.test(address.address)) {\n          address.address = address.address.substr(0, address.address.lastIndexOf('@') + 1) + punycode.toUnicode(address.address.substr(address.address.lastIndexOf('@') + 1));\n        }\n\n        if (address.group) {\n          this.decodeAddresses(address.group);\n        }\n      }\n    }\n  }, {\n    key: \"createNode\",\n    value: function createNode(node) {\n      var _this8 = this;\n\n      var contentType = node.contentType;\n      var disposition = node.disposition;\n      var encoding = node.encoding;\n      var charset = node.charset;\n\n      if (!contentType && node.root) {\n        contentType = 'text/plain';\n      }\n\n      var newNode = {\n        node: node,\n        headerLines: node.headers.lines,\n        headers: this.processHeaders(node.headers.getList()),\n        contentType: contentType,\n        children: []\n      };\n\n      if (!/^multipart\\//i.test(contentType)) {\n        if (disposition && !['attachment', 'inline'].includes(disposition)) {\n          disposition = 'attachment';\n        }\n\n        if (!disposition && !['text/plain', 'text/html'].includes(contentType)) {\n          newNode.disposition = 'attachment';\n        } else {\n          newNode.disposition = disposition || 'inline';\n        }\n\n        newNode.isAttachment = !['text/plain', 'text/html'].includes(contentType) || newNode.disposition !== 'inline';\n        newNode.encoding = ['quoted-printable', 'base64'].includes(encoding) ? encoding : 'binary';\n\n        if (charset) {\n          newNode.charset = charset;\n        }\n\n        var decoder = node.getDecoder();\n        decoder.on('end', function () {\n          _this8.decoderEnded = true;\n        });\n        newNode.decoder = decoder;\n      }\n\n      if (node.root) {\n        this.headers = newNode.headers;\n        this.headerLines = newNode.headerLines;\n      } // find location in tree\n\n\n      if (!this.tree) {\n        newNode.root = true;\n        this.curnode = this.tree = newNode;\n        return newNode;\n      } // immediate child of root node\n\n\n      if (!this.curnode.parent) {\n        newNode.parent = this.curnode;\n        this.curnode.children.push(newNode);\n        this.curnode = newNode;\n        return newNode;\n      } // siblings\n\n\n      if (this.curnode.parent.node === node.parentNode) {\n        newNode.parent = this.curnode.parent;\n        this.curnode.parent.children.push(newNode);\n        this.curnode = newNode;\n        return newNode;\n      } // first child\n\n\n      if (this.curnode.node === node.parentNode) {\n        newNode.parent = this.curnode;\n        this.curnode.children.push(newNode);\n        this.curnode = newNode;\n        return newNode;\n      } // move up\n\n\n      var parentNode = this.curnode;\n\n      while (parentNode = parentNode.parent) {\n        if (parentNode.node === node.parentNode) {\n          newNode.parent = parentNode;\n          parentNode.children.push(newNode);\n          this.curnode = newNode;\n          return newNode;\n        }\n      } // should never happen, can't detect parent\n\n\n      this.curnode = newNode;\n      return newNode;\n    }\n  }, {\n    key: \"getTextContent\",\n    value: function getTextContent() {\n      var _this9 = this;\n\n      var text = [];\n      var html = [];\n\n      var processNode = function processNode(alternative, level, node) {\n        if (node.showMeta) {\n          var meta = ['From', 'Subject', 'Date', 'To', 'Cc', 'Bcc'].map(function (fkey) {\n            var key = fkey.toLowerCase();\n\n            if (!node.headers.has(key)) {\n              return false;\n            }\n\n            var value = node.headers.get(key);\n\n            if (!value) {\n              return false;\n            }\n\n            return {\n              key: fkey,\n              value: Array.isArray(value) ? value[value.length - 1] : value\n            };\n          }).filter(function (entry) {\n            return entry;\n          });\n\n          if (_this9.hasHtml) {\n            html.push('<table class=\"mp_head\">' + meta.map(function (entry) {\n              var value = entry.value;\n\n              switch (entry.key) {\n                case 'From':\n                case 'To':\n                case 'Cc':\n                case 'Bcc':\n                  value = value.html;\n                  break;\n\n                case 'Date':\n                  value = _this9.options.formatDateString ? _this9.options.formatDateString(value) : value.toUTCString();\n                  break;\n\n                case 'Subject':\n                  value = '<strong>' + he.encode(value) + '</strong>';\n                  break;\n\n                default:\n                  value = he.encode(value);\n              }\n\n              return '<tr><td class=\"mp_head_key\">' + he.encode(entry.key) + ':</td><td class=\"mp_head_value\">' + value + '<td></tr>';\n            }).join('\\n') + '<table>');\n          }\n\n          if (_this9.hasText) {\n            text.push('\\n' + meta.map(function (entry) {\n              var value = entry.value;\n\n              switch (entry.key) {\n                case 'From':\n                case 'To':\n                case 'Cc':\n                case 'Bcc':\n                  value = value.text;\n                  break;\n\n                case 'Date':\n                  value = _this9.options.formatDateString ? _this9.options.formatDateString(value) : value.toUTCString();\n                  break;\n              }\n\n              return entry.key + ': ' + value;\n            }).join('\\n') + '\\n');\n          }\n        }\n\n        if (node.textContent) {\n          if (node.contentType === 'text/plain') {\n            text.push(node.textContent);\n\n            if (!alternative && _this9.hasHtml) {\n              html.push(_this9.textToHtml(node.textContent));\n            }\n          } else if (node.contentType === 'text/html') {\n            var failedToParseHtml = false;\n\n            if (!alternative && _this9.hasText || node.root && !_this9.hasText) {\n              if (_this9.options.skipHtmlToText) {\n                text.push('');\n              } else if (node.textContent.length > _this9.options.maxHtmlLengthToParse) {\n                _this9.emit('error', new Error(\"HTML too long for parsing \".concat(node.textContent.length, \" bytes\")));\n\n                text.push('Invalid HTML content (too long)');\n                failedToParseHtml = true;\n              } else {\n                try {\n                  text.push(htmlToText.fromString(node.textContent));\n                } catch (err) {\n                  _this9.emit('error', new Error('Failed to parse HTML'));\n\n                  text.push('Invalid HTML content');\n                  failedToParseHtml = true;\n                }\n              }\n            }\n\n            if (!failedToParseHtml) {\n              html.push(node.textContent);\n            }\n          }\n        }\n\n        alternative = alternative || node.contentType === 'multipart/alternative';\n        node.children.forEach(function (subNode) {\n          processNode(alternative, level + 1, subNode);\n        });\n      };\n\n      processNode(false, 0, this.tree);\n      var response = {\n        type: 'text'\n      };\n\n      if (html.length) {\n        this.html = response.html = html.join('<br/>\\n');\n      }\n\n      if (text.length) {\n        this.text = response.text = text.join('\\n');\n        this.textAsHtml = response.textAsHtml = text.map(function (part) {\n          return _this9.textToHtml(part);\n        }).join('<br/>\\n');\n      }\n\n      return response;\n    }\n  }, {\n    key: \"processChunk\",\n    value: function processChunk(data, done) {\n      var _this10 = this;\n\n      var partId = null;\n\n      if (data._parentBoundary) {\n        partId = this._getPartId(data._parentBoundary);\n      }\n\n      switch (data.type) {\n        case 'node':\n          {\n            var node = this.createNode(data);\n\n            if (node === this.tree) {\n              ['subject', 'references', 'date', 'to', 'from', 'to', 'cc', 'bcc', 'message-id', 'in-reply-to', 'reply-to'].forEach(function (key) {\n                if (node.headers.has(key)) {\n                  _this10[key.replace(/-([a-z])/g, function (m, c) {\n                    return c.toUpperCase();\n                  })] = node.headers.get(key);\n                }\n              });\n              this.emit('headers', node.headers);\n            }\n\n            if (data.contentType === 'message/rfc822' && data.messageNode) {\n              break;\n            }\n\n            if (data.parentNode && data.parentNode.contentType === 'message/rfc822') {\n              node.showMeta = true;\n            }\n\n            if (node.isAttachment) {\n              var contentType = node.contentType;\n\n              if (node.contentType === 'application/octet-stream' && data.filename) {\n                contentType = this.libmime.detectMimeType(data.filename) || 'application/octet-stream';\n              }\n\n              var attachment = {\n                type: 'attachment',\n                content: null,\n                contentType: contentType,\n                partId: partId,\n                release: function release() {\n                  attachment.release = null;\n\n                  if (_this10.waitUntilAttachmentEnd && typeof _this10.attachmentCallback === 'function') {\n                    setImmediate(_this10.attachmentCallback);\n                  }\n\n                  _this10.attachmentCallback = false;\n                  _this10.waitUntilAttachmentEnd = false;\n                }\n              };\n              var hasher = new StreamHash(attachment, 'md5');\n              node.decoder.on('error', function (err) {\n                hasher.emit('error', err);\n              });\n              node.decoder.on('readable', function () {\n                var chunk;\n\n                while ((chunk = node.decoder.read()) !== null) {\n                  hasher.write(chunk);\n                }\n              });\n              node.decoder.once('end', function () {\n                hasher.end();\n              }); //node.decoder.pipe(hasher);\n\n              attachment.content = hasher;\n              this.waitUntilAttachmentEnd = true;\n\n              if (data.disposition) {\n                attachment.contentDisposition = data.disposition;\n              }\n\n              if (data.filename) {\n                attachment.filename = data.filename;\n              }\n\n              if (node.headers.has('content-id')) {\n                attachment.contentId = [].concat(node.headers.get('content-id') || []).shift();\n                attachment.cid = attachment.contentId.trim().replace(/^<|>$/g, '').trim(); // check if the attachment is \"related\" to text content like an embedded image etc\n\n                var parentNode = node;\n\n                while (parentNode = parentNode.parent) {\n                  if (parentNode.contentType === 'multipart/related') {\n                    attachment.related = true;\n                  }\n                }\n              }\n\n              attachment.headers = node.headers;\n              this.push(attachment);\n              this.attachmentList.push(attachment);\n            } else if (node.disposition === 'inline') {\n              var chunks = [];\n              var chunklen = 0;\n              node.contentStream = node.decoder;\n\n              if (node.contentType === 'text/plain') {\n                this.hasText = true;\n              } else if (node.contentType === 'text/html') {\n                this.hasHtml = true;\n              }\n\n              if (node.node.flowed) {\n                var contentStream = node.contentStream;\n                var flowDecoder = new FlowedDecoder({\n                  delSp: node.node.delSp\n                });\n                contentStream.on('error', function (err) {\n                  flowDecoder.emit('error', err);\n                });\n                contentStream.pipe(flowDecoder);\n                node.contentStream = flowDecoder;\n              }\n\n              var charset = node.charset || 'utf-8'; //charset = charset || 'windows-1257';\n\n              if (!['ascii', 'usascii', 'utf8'].includes(charset.toLowerCase().replace(/[^a-z0-9]+/g, ''))) {\n                try {\n                  var _contentStream = node.contentStream;\n                  var decodeStream = this.decoder.decodeStream(charset);\n\n                  _contentStream.on('error', function (err) {\n                    decodeStream.emit('error', err);\n                  });\n\n                  _contentStream.pipe(decodeStream);\n\n                  node.contentStream = decodeStream;\n                } catch (E) {// do not decode charset\n                }\n              }\n\n              node.contentStream.on('readable', function () {\n                var chunk;\n\n                while ((chunk = node.contentStream.read()) !== null) {\n                  if (typeof chunk === 'string') {\n                    chunk = Buffer.from(chunk);\n                  }\n\n                  chunks.push(chunk);\n                  chunklen += chunk.length;\n                }\n              });\n              node.contentStream.once('end', function () {\n                node.textContent = Buffer.concat(chunks, chunklen).toString().replace(/\\r?\\n/g, '\\n');\n              });\n              node.contentStream.once('error', function (err) {\n                _this10.emit('error', err);\n              });\n            }\n\n            break;\n          }\n\n        case 'data':\n          if (this.curnode && this.curnode.decoder) {\n            this.curnode.decoder.end();\n          }\n\n          if (this.waitUntilAttachmentEnd) {\n            this.attachmentCallback = done;\n            return;\n          } // multipart message structure\n          // this is not related to any specific 'node' block as it includes\n          // everything between the end of some node body and between the next header\n          //process.stdout.write(data.value);\n\n\n          break;\n\n        case 'body':\n          if (this.curnode && this.curnode.decoder && this.curnode.decoder.writable) {\n            if (this.curnode.decoder.write(data.value) === false) {\n              return this.curnode.decoder.once('drain', done);\n            }\n          } // Leaf element body. Includes the body for the last 'node' block. You might\n          // have several 'body' calls for a single 'node' block\n          //process.stdout.write(data.value);\n\n\n          break;\n      }\n\n      setImmediate(done);\n    }\n  }, {\n    key: \"_getPartId\",\n    value: function _getPartId(parentBoundary) {\n      var boundaryIndex = this.boundaries.findIndex(function (item) {\n        return item.name === parentBoundary;\n      });\n\n      if (boundaryIndex === -1) {\n        this.boundaries.push({\n          name: parentBoundary,\n          count: 1\n        });\n        boundaryIndex = this.boundaries.length - 1;\n      } else {\n        this.boundaries[boundaryIndex].count++;\n      }\n\n      var partId = '1';\n\n      for (var i = 0; i <= boundaryIndex; i++) {\n        if (i === 0) partId = this.boundaries[i].count.toString();else partId += '.' + this.boundaries[i].count.toString();\n      }\n\n      return partId;\n    }\n  }, {\n    key: \"getAddressesHTML\",\n    value: function getAddressesHTML(value) {\n      var formatSingleLevel = function formatSingleLevel(addresses) {\n        return addresses.map(function (address) {\n          var str = '<span class=\"mp_address_group\">';\n\n          if (address.name) {\n            str += '<span class=\"mp_address_name\">' + he.encode(address.name) + (address.group ? ': ' : '') + '</span>';\n          }\n\n          if (address.address) {\n            var link = '<a href=\"mailto:' + he.encode(address.address) + '\" class=\"mp_address_email\">' + he.encode(address.address) + '</a>';\n\n            if (address.name) {\n              str += ' &lt;' + link + '&gt;';\n            } else {\n              str += link;\n            }\n          }\n\n          if (address.group) {\n            str += formatSingleLevel(address.group) + ';';\n          }\n\n          return str + '</span>';\n        }).join(', ');\n      };\n\n      return formatSingleLevel([].concat(value || []));\n    }\n  }, {\n    key: \"getAddressesText\",\n    value: function getAddressesText(value) {\n      var formatSingleLevel = function formatSingleLevel(addresses) {\n        return addresses.map(function (address) {\n          var str = '';\n\n          if (address.name) {\n            str += address.name + (address.group ? ': ' : '');\n          }\n\n          if (address.address) {\n            var link = address.address;\n\n            if (address.name) {\n              str += ' <' + link + '>';\n            } else {\n              str += link;\n            }\n          }\n\n          if (address.group) {\n            str += formatSingleLevel(address.group) + ';';\n          }\n\n          return str;\n        }).join(', ');\n      };\n\n      return formatSingleLevel([].concat(value || []));\n    }\n  }, {\n    key: \"updateImageLinks\",\n    value: function updateImageLinks(replaceCallback, done) {\n      var _this11 = this;\n\n      if (!this.html) {\n        return setImmediate(function () {\n          return done(null, false);\n        });\n      }\n\n      var cids = new Map();\n      var html = (this.html || '').toString();\n\n      if (this.options.skipImageLinks) {\n        return done(null, html);\n      }\n\n      html.replace(/\\bcid:([^'\"\\s]{1,256})/g, function (match, cid) {\n        for (var i = 0, len = _this11.attachmentList.length; i < len; i++) {\n          if (_this11.attachmentList[i].cid === cid && /^image\\/[\\w]+$/i.test(_this11.attachmentList[i].contentType)) {\n            if (/^image\\/[\\w]+$/i.test(_this11.attachmentList[i].contentType)) {\n              cids.set(cid, {\n                attachment: _this11.attachmentList[i]\n              });\n            }\n\n            break;\n          }\n        }\n\n        return match;\n      });\n      var cidList = [];\n      cids.forEach(function (entry) {\n        cidList.push(entry);\n      });\n      var pos = 0;\n\n      var processNext = function processNext() {\n        if (pos >= cidList.length) {\n          html = html.replace(/\\bcid:([^'\"\\s]{1,256})/g, function (match, cid) {\n            if (cids.has(cid) && cids.get(cid).url) {\n              return cids.get(cid).url;\n            }\n\n            return match;\n          });\n          return done(null, html);\n        }\n\n        var entry = cidList[pos++];\n        replaceCallback(entry.attachment, function (err, url) {\n          if (err) {\n            return setImmediate(function () {\n              return done(err);\n            });\n          }\n\n          entry.url = url;\n          setImmediate(processNext);\n        });\n      };\n\n      setImmediate(processNext);\n    }\n  }, {\n    key: \"textToHtml\",\n    value: function textToHtml(str) {\n      if (this.options.skipTextToHtml) {\n        return '';\n      }\n\n      str = (str || '').toString();\n      var encoded;\n      var linkified = false;\n\n      if (!this.options.skipTextLinks) {\n        try {\n          if (linkify.pretest(str)) {\n            linkified = true;\n            var links = linkify.match(str) || [];\n            var result = [];\n            var last = 0;\n            links.forEach(function (link) {\n              if (last < link.index) {\n                var _textPart = he // encode special chars\n                .encode(str.slice(last, link.index), {\n                  useNamedReferences: true\n                });\n\n                result.push(_textPart);\n              }\n\n              result.push(\"<a href=\\\"\".concat(link.url, \"\\\">\").concat(link.text, \"</a>\"));\n              last = link.lastIndex;\n            });\n            var textPart = he // encode special chars\n            .encode(str.slice(last), {\n              useNamedReferences: true\n            });\n            result.push(textPart);\n            encoded = result.join('');\n          }\n        } catch (E) {// failed, don't linkify\n        }\n      }\n\n      if (!linkified) {\n        encoded = he // encode special chars\n        .encode(str, {\n          useNamedReferences: true\n        });\n      }\n\n      var text = '<p>' + encoded.replace(/\\r?\\n/g, '\\n').trim() // normalize line endings\n      .replace(/[ \\t]+$/gm, '').trim() // trim empty line endings\n      .replace(/\\n\\n+/g, '</p><p>').trim() // insert <p> to multiple linebreaks\n      .replace(/\\n/g, '<br/>') + // insert <br> to single linebreaks\n      '</p>';\n      return text;\n    }\n  }]);\n\n  return MailParser;\n}(Transform);\n\nmodule.exports = MailParser;","map":null,"metadata":{},"sourceType":"script"}