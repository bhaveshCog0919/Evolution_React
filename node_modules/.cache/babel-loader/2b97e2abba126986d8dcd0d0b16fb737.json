{"ast":null,"code":"'use strict';\n\nconst Transform = require('stream').Transform;\n\nconst MimeNode = require('./mime-node');\n\nconst MAX_HEAD_SIZE = 1 * 1024 * 1024;\nconst MAX_CHILD_NODES = 1000;\nconst HEAD = 0x01;\nconst BODY = 0x02;\n\nclass MessageSplitter extends Transform {\n  constructor(config) {\n    let options = {\n      readableObjectMode: true,\n      writableObjectMode: false\n    };\n    super(options);\n    this.config = config || {};\n    this.maxHeadSize = this.config.maxHeadSize || MAX_HEAD_SIZE;\n    this.maxChildNodes = this.config.maxChildNodes || MAX_CHILD_NODES;\n    this.tree = [];\n    this.nodeCounter = 0;\n    this.newNode();\n    this.tree.push(this.node);\n    this.line = false;\n    this.errored = false;\n  }\n\n  _transform(chunk, encoding, callback) {\n    // process line by line\n    // find next line ending\n    let pos = 0;\n    let i = 0;\n    let group = {\n      type: 'none'\n    };\n    let groupstart = this.line ? -this.line.length : 0;\n    let groupend = 0;\n\n    let checkTrailingLinebreak = data => {\n      if (data.type === 'body' && data.node.parentNode && data.value && data.value.length) {\n        if (data.value[data.value.length - 1] === 0x0a) {\n          groupstart--;\n          groupend--;\n          pos--;\n\n          if (data.value.length > 1 && data.value[data.value.length - 2] === 0x0d) {\n            groupstart--;\n            groupend--;\n            pos--;\n\n            if (groupstart < 0 && !this.line) {\n              // store only <CR> as <LF> should be on the positive side\n              this.line = Buffer.allocUnsafe(1);\n              this.line[0] = 0x0d;\n            }\n\n            data.value = data.value.slice(0, data.value.length - 2);\n          } else {\n            data.value = data.value.slice(0, data.value.length - 1);\n          }\n        } else if (data.value[data.value.length - 1] === 0x0d) {\n          groupstart--;\n          groupend--;\n          pos--;\n          data.value = data.value.slice(0, data.value.length - 1);\n        }\n      }\n    };\n\n    let iterateData = () => {\n      for (let len = chunk.length; i < len; i++) {\n        // find next <LF>\n        if (chunk[i] === 0x0a) {\n          // line end\n          let start = Math.max(pos, 0);\n          pos = ++i;\n          return this.processLine(chunk.slice(start, i), false, (err, data, flush) => {\n            if (err) {\n              this.errored = true;\n              return setImmediate(() => callback(err));\n            }\n\n            if (!data) {\n              return setImmediate(iterateData);\n            }\n\n            if (flush) {\n              if (group && group.type !== 'none') {\n                if (group.type === 'body' && groupend >= groupstart && group.node.parentNode) {\n                  // do not include the last line ending for body\n                  if (chunk[groupend - 1] === 0x0a) {\n                    groupend--;\n\n                    if (groupend >= groupstart && chunk[groupend - 1] === 0x0d) {\n                      groupend--;\n                    }\n                  }\n                }\n\n                if (groupstart !== groupend) {\n                  group.value = chunk.slice(groupstart, groupend);\n\n                  if (groupend < i) {\n                    data.value = chunk.slice(groupend, i);\n                  }\n                }\n\n                this.push(group);\n                group = {\n                  type: 'none'\n                };\n                groupstart = groupend = i;\n              }\n\n              this.push(data);\n              groupend = i;\n              return setImmediate(iterateData);\n            }\n\n            if (data.type === group.type) {\n              // shift slice end position forward\n              groupend = i;\n            } else {\n              if (group.type === 'body' && groupend >= groupstart && group.node.parentNode) {\n                // do not include the last line ending for body\n                if (chunk[groupend - 1] === 0x0a) {\n                  groupend--;\n\n                  if (groupend >= groupstart && chunk[groupend - 1] === 0x0d) {\n                    groupend--;\n                  }\n                }\n              }\n\n              if (group.type !== 'none' && group.type !== 'node') {\n                // we have a previous data/body chunk to output\n                if (groupstart !== groupend) {\n                  group.value = chunk.slice(groupstart, groupend);\n\n                  if (group.value && group.value.length) {\n                    this.push(group);\n                    group = {\n                      type: 'none'\n                    };\n                  }\n                }\n              }\n\n              if (data.type === 'node') {\n                this.push(data);\n                groupstart = i;\n                groupend = i;\n              } else if (groupstart < 0) {\n                groupstart = i;\n                groupend = i;\n                checkTrailingLinebreak(data);\n\n                if (data.value && data.value.length) {\n                  this.push(data);\n                }\n              } else {\n                // start new body/data chunk\n                group = data;\n                groupstart = groupend;\n                groupend = i;\n              }\n            }\n\n            return setImmediate(iterateData);\n          });\n        }\n      } // skip last linebreak for body\n\n\n      if (pos >= groupstart + 1 && group.type === 'body' && group.node.parentNode) {\n        // do not include the last line ending for body\n        if (chunk[pos - 1] === 0x0a) {\n          pos--;\n\n          if (pos >= groupstart && chunk[pos - 1] === 0x0d) {\n            pos--;\n          }\n        }\n      }\n\n      if (group.type !== 'none' && group.type !== 'node' && pos > groupstart) {\n        // we have a leftover data/body chunk to push out\n        group.value = chunk.slice(groupstart, pos);\n\n        if (group.value && group.value.length) {\n          this.push(group);\n          group = {\n            type: 'none'\n          };\n        }\n      }\n\n      if (pos < chunk.length) {\n        if (this.line) {\n          this.line = Buffer.concat([this.line, chunk.slice(pos)]);\n        } else {\n          this.line = chunk.slice(pos);\n        }\n      }\n\n      callback();\n    };\n\n    setImmediate(iterateData);\n  }\n\n  _flush(callback) {\n    if (this.errored) {\n      return callback();\n    }\n\n    this.processLine(false, true, (err, data) => {\n      if (err) {\n        return setImmediate(() => callback(err));\n      }\n\n      if (data && (data.type === 'node' || data.value && data.value.length)) {\n        this.push(data);\n      }\n\n      callback();\n    });\n  }\n\n  compareBoundary(line, startpos, boundary) {\n    // --{boundary}\\r\\n or --{boundary}--\\r\\n\n    if (line.length < boundary.length + 3 + startpos || line.length > boundary.length + 6 + startpos) {\n      return false;\n    }\n\n    for (let i = 0; i < boundary.length; i++) {\n      if (line[i + 2 + startpos] !== boundary[i]) {\n        return false;\n      }\n    }\n\n    let pos = 0;\n\n    for (let i = boundary.length + 2 + startpos; i < line.length; i++) {\n      let c = line[i];\n\n      if (pos === 0 && (c === 0x0d || c === 0x0a)) {\n        // 1: next node\n        return 1;\n      }\n\n      if (pos === 0 && c !== 0x2d) {\n        // expecting \"-\"\n        return false;\n      }\n\n      if (pos === 1 && c !== 0x2d) {\n        // expecting \"-\"\n        return false;\n      }\n\n      if (pos === 2 && c !== 0x0d && c !== 0x0a) {\n        // expecting line terminator, either <CR> or <LF>\n        return false;\n      }\n\n      if (pos === 3 && c !== 0x0a) {\n        // expecting line terminator <LF>\n        return false;\n      }\n\n      pos++;\n    } // 2: multipart end\n\n\n    return 2;\n  }\n\n  checkBoundary(line) {\n    let startpos = 0;\n\n    if (line.length >= 1 && (line[0] === 0x0d || line[0] === 0x0a)) {\n      startpos++;\n\n      if (line.length >= 2 && (line[0] === 0x0d || line[1] === 0x0a)) {\n        startpos++;\n      }\n    }\n\n    if (line.length < 4 || line[startpos] !== 0x2d || line[startpos + 1] !== 0x2d) {\n      // defnitely not a boundary\n      return false;\n    }\n\n    let boundary;\n\n    if (this.node._boundary && (boundary = this.compareBoundary(line, startpos, this.node._boundary))) {\n      // 1: next child\n      // 2: multipart end\n      return boundary;\n    }\n\n    if (this.node._parentBoundary && (boundary = this.compareBoundary(line, startpos, this.node._parentBoundary))) {\n      // 3: next sibling\n      // 4: parent end\n      return boundary + 2;\n    }\n\n    return false;\n  }\n\n  processLine(line, final, next) {\n    let flush = false;\n\n    if (this.line && line) {\n      line = Buffer.concat([this.line, line]);\n      this.line = false;\n    } else if (this.line && !line) {\n      line = this.line;\n      this.line = false;\n    }\n\n    if (!line) {\n      line = Buffer.alloc(0);\n    }\n\n    if (this.nodeCounter > this.maxChildNodes) {\n      let err = new Error('Max allowed child nodes exceeded');\n      err.code = 'EMAXLEN';\n      return next(err);\n    } // we check boundary outside the HEAD/BODY scope as it may appear anywhere\n\n\n    let boundary = this.checkBoundary(line);\n\n    if (boundary) {\n      // reached boundary, switch context\n      switch (boundary) {\n        case 1:\n          // next child\n          this.newNode(this.node);\n          flush = true;\n          break;\n\n        case 2:\n          // reached end of children, keep current node\n          break;\n\n        case 3:\n          {\n            // next sibling\n            let parentNode = this.node.parentNode;\n\n            if (parentNode && parentNode.contentType === 'message/rfc822') {\n              // special case where immediate parent is an inline message block\n              // move up another step\n              parentNode = parentNode.parentNode;\n            }\n\n            this.newNode(parentNode);\n            flush = true;\n            break;\n          }\n\n        case 4:\n          // special case when boundary close a node with only header.\n          if (this.node && this.node._headerlen && !this.node.headers) {\n            this.node.parseHeaders();\n            this.push(this.node);\n          } // move up\n\n\n          if (this.tree.length) {\n            this.node = this.tree.pop();\n          }\n\n          this.state = BODY;\n          break;\n      }\n\n      return next(null, {\n        node: this.node,\n        type: 'data',\n        value: line\n      }, flush);\n    }\n\n    switch (this.state) {\n      case HEAD:\n        {\n          this.node.addHeaderChunk(line);\n\n          if (this.node._headerlen > this.maxHeadSize) {\n            let err = new Error('Max header size for a MIME node exceeded');\n            err.code = 'EMAXLEN';\n            return next(err);\n          }\n\n          if (final || line.length === 1 && line[0] === 0x0a || line.length === 2 && line[0] === 0x0d && line[1] === 0x0a) {\n            let currentNode = this.node;\n            currentNode.parseHeaders(); // if the content is attached message then just continue\n\n            if (currentNode.contentType === 'message/rfc822' && !this.config.ignoreEmbedded && (!currentNode.encoding || ['7bit', '8bit', 'binary'].includes(currentNode.encoding)) && currentNode.disposition !== 'attachment') {\n              currentNode.messageNode = true;\n              this.newNode(currentNode);\n\n              if (currentNode.parentNode) {\n                this.node._parentBoundary = currentNode.parentNode._boundary;\n              }\n            } else {\n              if (currentNode.contentType === 'message/rfc822') {\n                currentNode.messageNode = false;\n              }\n\n              this.state = BODY;\n\n              if (currentNode.multipart && currentNode._boundary) {\n                this.tree.push(currentNode);\n              }\n            }\n\n            return next(null, currentNode, flush);\n          }\n\n          return next();\n        }\n\n      case BODY:\n        {\n          return next(null, {\n            node: this.node,\n            type: this.node.multipart ? 'data' : 'body',\n            value: line\n          }, flush);\n        }\n    }\n\n    next(null, false);\n  }\n\n  newNode(parent) {\n    this.node = new MimeNode(parent || false, this.config);\n    this.state = HEAD;\n    this.nodeCounter++;\n  }\n\n}\n\nmodule.exports = MessageSplitter;","map":null,"metadata":{},"sourceType":"script"}