{"ast":null,"code":"'use strict'; // Helper class to rewrite nodes with specific mime type\n\nconst Transform = require('stream').Transform;\n\nconst FlowedDecoder = require('./flowed-decoder');\n/**\n * NodeRewriter Transform stream. Updates content for all nodes with specified mime type\n *\n * @constructor\n * @param {String} mimeType Define the Mime-Type to look for\n * @param {Function} rewriteAction Function to run with the node content\n */\n\n\nclass NodeRewriter extends Transform {\n  constructor(filterFunc, rewriteAction) {\n    let options = {\n      readableObjectMode: true,\n      writableObjectMode: true\n    };\n    super(options);\n    this.filterFunc = filterFunc;\n    this.rewriteAction = rewriteAction;\n    this.decoder = false;\n    this.encoder = false;\n    this.continue = false;\n  }\n\n  _transform(data, encoding, callback) {\n    this.processIncoming(data, callback);\n  }\n\n  _flush(callback) {\n    if (this.decoder) {\n      // emit an empty node just in case there is pending data to end\n      return this.processIncoming({\n        type: 'none'\n      }, callback);\n    }\n\n    return callback();\n  }\n\n  processIncoming(data, callback) {\n    if (this.decoder && data.type === 'body') {\n      // data to parse\n      if (!this.decoder.write(data.value)) {\n        return this.decoder.once('drain', callback);\n      } else {\n        return callback();\n      }\n    } else if (this.decoder && data.type !== 'body') {\n      // stop decoding.\n      // we can not process the current data chunk as we need to wait until\n      // the parsed data is completely processed, so we store a reference to the\n      // continue callback\n      this.continue = () => {\n        this.continue = false;\n        this.decoder = false;\n        this.encoder = false;\n        this.processIncoming(data, callback);\n      };\n\n      return this.decoder.end();\n    } else if (data.type === 'node' && this.filterFunc(data)) {\n      // found matching node, create new handler\n      this.emit('node', this.createDecodePair(data));\n    } else if (this.readable && data.type !== 'none') {\n      // we don't care about this data, just pass it over to the joiner\n      this.push(data);\n    }\n\n    callback();\n  }\n\n  createDecodePair(node) {\n    this.decoder = node.getDecoder();\n\n    if (['base64', 'quoted-printable'].includes(node.encoding)) {\n      this.encoder = node.getEncoder();\n    } else {\n      this.encoder = node.getEncoder('quoted-printable');\n    }\n\n    let lastByte = false;\n    let decoder = this.decoder;\n    let encoder = this.encoder;\n    let firstChunk = true;\n    decoder.$reading = false;\n\n    let readFromEncoder = () => {\n      decoder.$reading = true;\n      let data = encoder.read();\n\n      if (data === null) {\n        decoder.$reading = false;\n        return;\n      }\n\n      if (firstChunk) {\n        firstChunk = false;\n\n        if (this.readable) {\n          this.push(node);\n\n          if (node.type === 'body') {\n            lastByte = node.value && node.value.length && node.value[node.value.length - 1];\n          }\n        }\n      }\n\n      let writeMore = true;\n\n      if (this.readable) {\n        writeMore = this.push({\n          node,\n          type: 'body',\n          value: data\n        });\n        lastByte = data && data.length && data[data.length - 1];\n      }\n\n      if (writeMore) {\n        return setImmediate(readFromEncoder);\n      } else {\n        encoder.pause(); // no idea how to catch drain? use timeout for now as poor man's substitute\n        // this.once('drain', () => encoder.resume());\n\n        setTimeout(() => {\n          encoder.resume();\n          setImmediate(readFromEncoder);\n        }, 100);\n      }\n    };\n\n    encoder.on('readable', () => {\n      if (!decoder.$reading) {\n        return readFromEncoder();\n      }\n    });\n    encoder.on('end', () => {\n      if (firstChunk) {\n        firstChunk = false;\n\n        if (this.readable) {\n          this.push(node);\n\n          if (node.type === 'body') {\n            lastByte = node.value && node.value.length && node.value[node.value.length - 1];\n          }\n        }\n      }\n\n      if (lastByte !== 0x0a) {\n        // make sure there is a terminating line break\n        this.push({\n          node,\n          type: 'body',\n          value: Buffer.from([0x0a])\n        });\n      }\n\n      if (this.continue) {\n        return this.continue();\n      }\n    });\n\n    if (/^text\\//.test(node.contentType) && node.flowed) {\n      // text/plain; format=flowed is a special case\n      let flowDecoder = decoder;\n      decoder = new FlowedDecoder({\n        delSp: node.delSp,\n        encoding: node.encoding\n      });\n      flowDecoder.on('error', err => {\n        decoder.emit('error', err);\n      });\n      flowDecoder.pipe(decoder); // we don't know what kind of data we are going to get, does it comply with the\n      // requirements of format=flowed, so we just cancel it\n\n      node.flowed = false;\n      node.delSp = false;\n      node.setContentType();\n    }\n\n    return {\n      node,\n      decoder,\n      encoder\n    };\n  }\n\n}\n\nmodule.exports = NodeRewriter;","map":null,"metadata":{},"sourceType":"script"}