{"ast":null,"code":"'use strict'; // Helper class to rewrite nodes with specific mime type\n\nconst Transform = require('stream').Transform;\n\nconst FlowedDecoder = require('./flowed-decoder');\n/**\n * NodeRewriter Transform stream. Updates content for all nodes with specified mime type\n *\n * @constructor\n * @param {String} mimeType Define the Mime-Type to look for\n * @param {Function} streamAction Function to run with the node content\n */\n\n\nclass NodeStreamer extends Transform {\n  constructor(filterFunc, streamAction) {\n    let options = {\n      readableObjectMode: true,\n      writableObjectMode: true\n    };\n    super(options);\n    this.filterFunc = filterFunc;\n    this.streamAction = streamAction;\n    this.decoder = false;\n    this.canContinue = false;\n    this.continue = false;\n  }\n\n  _transform(data, encoding, callback) {\n    this.processIncoming(data, callback);\n  }\n\n  _flush(callback) {\n    if (this.decoder) {\n      // emit an empty node just in case there is pending data to end\n      return this.processIncoming({\n        type: 'none'\n      }, callback);\n    }\n\n    return callback();\n  }\n\n  processIncoming(data, callback) {\n    if (this.decoder && data.type === 'body') {\n      // data to parse\n      this.push(data);\n\n      if (!this.decoder.write(data.value)) {\n        return this.decoder.once('drain', callback);\n      } else {\n        return callback();\n      }\n    } else if (this.decoder && data.type !== 'body') {\n      // stop decoding.\n      // we can not process the current data chunk as we need to wait until\n      // the parsed data is completely processed, so we store a reference to the\n      // continue callback\n      let doContinue = () => {\n        this.continue = false;\n        this.decoder = false;\n        this.canContinue = false;\n        this.processIncoming(data, callback);\n      };\n\n      if (this.canContinue) {\n        setImmediate(doContinue);\n      } else {\n        this.continue = () => doContinue();\n      }\n\n      return this.decoder.end();\n    } else if (data.type === 'node' && this.filterFunc(data)) {\n      this.push(data); // found matching node, create new handler\n\n      this.emit('node', this.createDecoder(data));\n    } else if (this.readable && data.type !== 'none') {\n      // we don't care about this data, just pass it over to the joiner\n      this.push(data);\n    }\n\n    callback();\n  }\n\n  createDecoder(node) {\n    this.decoder = node.getDecoder();\n    let decoder = this.decoder;\n    decoder.$reading = false;\n\n    if (/^text\\//.test(node.contentType) && node.flowed) {\n      let flowDecoder = decoder;\n      decoder = new FlowedDecoder({\n        delSp: node.delSp\n      });\n      flowDecoder.on('error', err => {\n        decoder.emit('error', err);\n      });\n      flowDecoder.pipe(decoder);\n    }\n\n    return {\n      node,\n      decoder,\n      done: () => {\n        if (typeof this.continue === 'function') {\n          // called once input stream is processed\n          this.continue();\n        } else {\n          // called before input stream is processed\n          this.canContinue = true;\n        }\n      }\n    };\n  }\n\n}\n\nmodule.exports = NodeStreamer;","map":null,"metadata":{},"sourceType":"script"}