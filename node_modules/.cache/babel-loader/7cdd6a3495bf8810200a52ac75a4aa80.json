{"ast":null,"code":"'use strict';\n\nconst mailsplit = require('mailsplit');\n\nconst libmime = require('libmime');\n\nconst addressparser = require('nodemailer/lib/addressparser');\n\nconst Transform = require('stream').Transform;\n\nconst Splitter = mailsplit.Splitter;\n\nconst punycode = require('punycode');\n\nconst FlowedDecoder = require('mailsplit/lib/flowed-decoder');\n\nconst StreamHash = require('./stream-hash');\n\nconst iconv = require('iconv-lite');\n\nconst htmlToText = require('html-to-text');\n\nconst he = require('he');\n\nconst linkify = require('linkify-it')();\n\nconst tlds = require('tlds');\n\nconst encodingJapanese = require('encoding-japanese');\n\nlinkify.tlds(tlds) // Reload with full tlds list\n.tlds('onion', true) // Add unofficial `.onion` domain\n.add('git:', 'http:') // Add `git:` ptotocol as \"alias\"\n.add('ftp:', null) // Disable `ftp:` ptotocol\n.set({\n  fuzzyIP: true,\n  fuzzyLink: true,\n  fuzzyEmail: true\n}); // twitter linkifier from\n// https://github.com/markdown-it/linkify-it#example-2-add-twitter-mentions-handler\n\nlinkify.add('@', {\n  validate(text, pos, self) {\n    let tail = text.slice(pos);\n\n    if (!self.re.twitter) {\n      self.re.twitter = new RegExp('^([a-zA-Z0-9_]){1,15}(?!_)(?=$|' + self.re.src_ZPCc + ')');\n    }\n\n    if (self.re.twitter.test(tail)) {\n      // Linkifier allows punctuation chars before prefix,\n      // but we additionally disable `@` (\"@@mention\" is invalid)\n      if (pos >= 2 && tail[pos - 2] === '@') {\n        return false;\n      }\n\n      return tail.match(self.re.twitter)[0].length;\n    }\n\n    return 0;\n  },\n\n  normalize(match) {\n    match.url = 'https://twitter.com/' + match.url.replace(/^@/, '');\n  }\n\n});\n\nclass IconvDecoder extends Transform {\n  constructor(Iconv, charset) {\n    super(); // Iconv throws error on ks_c_5601-1987 when it is mapped to EUC-KR\n    // https://github.com/bnoordhuis/node-iconv/issues/169\n\n    if (charset.toLowerCase() === 'ks_c_5601-1987') {\n      charset = 'CP949';\n    }\n\n    this.stream = new Iconv(charset, 'UTF-8//TRANSLIT//IGNORE');\n    this.inputEnded = false;\n    this.endCb = false;\n    this.stream.on('error', err => this.emit('error', err));\n    this.stream.on('data', chunk => this.push(chunk));\n    this.stream.on('end', () => {\n      this.inputEnded = true;\n\n      if (typeof this.endCb === 'function') {\n        this.endCb();\n      }\n    });\n  }\n\n  _transform(chunk, encoding, done) {\n    this.stream.write(chunk);\n    done();\n  }\n\n  _flush(done) {\n    this.endCb = done;\n    this.stream.end();\n  }\n\n}\n\nclass JPDecoder extends Transform {\n  constructor(charset) {\n    super();\n    this.charset = charset;\n    this.chunks = [];\n    this.chunklen = 0;\n  }\n\n  _transform(chunk, encoding, done) {\n    if (typeof chunk === 'string') {\n      chunk = Buffer.from(chunk, encoding);\n    }\n\n    this.chunks.push(chunk);\n    this.chunklen += chunk.length;\n    done();\n  }\n\n  _flush(done) {\n    let input = Buffer.concat(this.chunks, this.chunklen);\n\n    try {\n      let output = encodingJapanese.convert(input, {\n        to: 'UNICODE',\n        // to_encoding\n        from: this.charset,\n        // from_encoding\n        type: 'string'\n      });\n\n      if (typeof output === 'string') {\n        output = Buffer.from(output);\n      }\n\n      this.push(output);\n    } catch (err) {\n      // keep as is on errors\n      this.push(input);\n    }\n\n    done();\n  }\n\n}\n\nclass MailParser extends Transform {\n  constructor(config) {\n    super({\n      readableObjectMode: true,\n      writableObjectMode: false\n    });\n    this.options = config || {};\n    this.splitter = new Splitter(config);\n    this.finished = false;\n    this.waitingEnd = false;\n    this.headers = false;\n    this.headerLines = false;\n    this.endReceived = false;\n    this.reading = false;\n    this.errored = false;\n    this.tree = false;\n    this.curnode = false;\n    this.waitUntilAttachmentEnd = false;\n    this.attachmentCallback = false;\n    this.hasHtml = false;\n    this.hasText = false;\n    this.text = false;\n    this.html = false;\n    this.textAsHtml = false;\n    this.attachmentList = [];\n    this.boundaries = [];\n    this.decoder = this.getDecoder();\n    this.splitter.on('readable', () => {\n      if (this.reading) {\n        return false;\n      }\n\n      this.readData();\n    });\n    this.splitter.on('end', () => {\n      this.endReceived = true;\n\n      if (!this.reading) {\n        this.endStream();\n      }\n    });\n    this.splitter.on('error', err => {\n      this.errored = true;\n\n      if (typeof this.waitingEnd === 'function') {\n        return this.waitingEnd(err);\n      }\n\n      this.emit('error', err);\n    });\n    this.libmime = new libmime.Libmime({\n      Iconv: this.options.Iconv\n    });\n  }\n\n  getDecoder() {\n    if (this.options.Iconv) {\n      const Iconv = this.options.Iconv; // create wrapper\n\n      return {\n        decodeStream(charset) {\n          return new IconvDecoder(Iconv, charset);\n        }\n\n      };\n    } else {\n      return {\n        decodeStream(charset) {\n          charset = (charset || 'ascii').toString().trim().toLowerCase();\n\n          if (/^jis|^iso-?2022-?jp|^EUCJP/i.test(charset)) {\n            // special case not supported by iconv-lite\n            return new JPDecoder(charset);\n          }\n\n          return iconv.decodeStream(charset);\n        }\n\n      };\n    }\n  }\n\n  readData() {\n    if (this.errored) {\n      return false;\n    }\n\n    this.reading = true;\n    let data = this.splitter.read();\n\n    if (data === null) {\n      this.reading = false;\n\n      if (this.endReceived) {\n        this.endStream();\n      }\n\n      return;\n    }\n\n    this.processChunk(data, err => {\n      if (err) {\n        if (typeof this.waitingEnd === 'function') {\n          return this.waitingEnd(err);\n        }\n\n        return this.emit('error', err);\n      }\n\n      setImmediate(() => this.readData());\n    });\n  }\n\n  endStream() {\n    this.finished = true;\n\n    if (this.curnode && this.curnode.decoder) {\n      this.curnode.decoder.end();\n    }\n\n    if (typeof this.waitingEnd === 'function') {\n      this.waitingEnd();\n    }\n  }\n\n  _transform(chunk, encoding, done) {\n    if (!chunk || !chunk.length) {\n      return done();\n    }\n\n    if (this.splitter.write(chunk) === false) {\n      return this.splitter.once('drain', () => {\n        done();\n      });\n    } else {\n      return done();\n    }\n  }\n\n  _flush(done) {\n    setImmediate(() => this.splitter.end());\n\n    if (this.finished) {\n      return this.cleanup(done);\n    }\n\n    this.waitingEnd = () => {\n      this.cleanup(() => {\n        done();\n      });\n    };\n  }\n\n  cleanup(done) {\n    let finish = () => {\n      let t = this.getTextContent();\n      this.push(t);\n      done();\n    };\n\n    if (this.curnode && this.curnode.decoder && this.curnode.decoder.readable && !this.decoderEnded) {\n      (this.curnode.contentStream || this.curnode.decoder).once('end', () => {\n        finish();\n      });\n      this.curnode.decoder.end();\n    } else {\n      setImmediate(() => {\n        finish();\n      });\n    }\n  }\n\n  processHeaders(lines) {\n    let headers = new Map();\n    (lines || []).forEach(line => {\n      let key = line.key;\n      let value = ((this.libmime.decodeHeader(line.line) || {}).value || '').toString().trim();\n      value = Buffer.from(value, 'binary').toString();\n\n      switch (key) {\n        case 'content-type':\n        case 'content-disposition':\n        case 'dkim-signature':\n          value = this.libmime.parseHeaderValue(value);\n\n          if (value.value) {\n            value.value = this.libmime.decodeWords(value.value);\n          }\n\n          Object.keys(value && value.params || {}).forEach(key => {\n            try {\n              value.params[key] = this.libmime.decodeWords(value.params[key]);\n            } catch (E) {// ignore, keep as is\n            }\n          });\n          break;\n\n        case 'date':\n          value = new Date(value);\n\n          if (!value || value.toString() === 'Invalid Date' || !value.getTime()) {\n            // date parsing failed :S\n            value = new Date();\n          }\n\n          break;\n\n        case 'subject':\n          try {\n            value = this.libmime.decodeWords(value);\n          } catch (E) {// ignore, keep as is\n          }\n\n          break;\n\n        case 'references':\n          try {\n            value = this.libmime.decodeWords(value);\n          } catch (E) {// ignore\n          }\n\n          value = value.split(/\\s+/).map(this.ensureMessageIDFormat);\n          break;\n\n        case 'message-id':\n        case 'in-reply-to':\n          try {\n            value = this.libmime.decodeWords(value);\n          } catch (E) {// ignore\n          }\n\n          value = this.ensureMessageIDFormat(value);\n          break;\n\n        case 'priority':\n        case 'x-priority':\n        case 'x-msmail-priority':\n        case 'importance':\n          key = 'priority';\n          value = this.parsePriority(value);\n          break;\n\n        case 'from':\n        case 'to':\n        case 'cc':\n        case 'bcc':\n        case 'sender':\n        case 'reply-to':\n        case 'delivered-to':\n        case 'return-path':\n          value = addressparser(value);\n          this.decodeAddresses(value);\n          value = {\n            value,\n            html: this.getAddressesHTML(value),\n            text: this.getAddressesText(value)\n          };\n          break;\n      } // handle list-* keys\n\n\n      if (key.substr(0, 5) === 'list-') {\n        value = this.parseListHeader(key.substr(5), value);\n        key = 'list';\n      }\n\n      if (value) {\n        if (!headers.has(key)) {\n          headers.set(key, [].concat(value || []));\n        } else if (Array.isArray(value)) {\n          headers.set(key, headers.get(key).concat(value));\n        } else {\n          headers.get(key).push(value);\n        }\n      }\n    }); // keep only the first value\n\n    let singleKeys = ['message-id', 'content-id', 'from', 'sender', 'in-reply-to', 'reply-to', 'subject', 'date', 'content-disposition', 'content-type', 'content-transfer-encoding', 'priority', 'mime-version', 'content-description', 'precedence', 'errors-to'];\n    headers.forEach((value, key) => {\n      if (Array.isArray(value)) {\n        if (singleKeys.includes(key) && value.length) {\n          headers.set(key, value[value.length - 1]);\n        } else if (value.length === 1) {\n          headers.set(key, value[0]);\n        }\n      }\n\n      if (key === 'list') {\n        // normalize List-* headers\n        let listValue = {};\n        [].concat(value || []).forEach(val => {\n          Object.keys(val || {}).forEach(listKey => {\n            listValue[listKey] = val[listKey];\n          });\n        });\n        headers.set(key, listValue);\n      }\n    });\n    return headers;\n  }\n\n  parseListHeader(key, value) {\n    let addresses = addressparser(value);\n    let response = {};\n    let data = addresses.map(address => {\n      if (/^https?:/i.test(address.name)) {\n        response.url = address.name;\n      } else if (address.name) {\n        response.name = address.name;\n      }\n\n      if (/^mailto:/.test(address.address)) {\n        response.mail = address.address.substr(7);\n      } else if (address.address && address.address.indexOf('@') < 0) {\n        response.id = address.address;\n      } else if (address.address) {\n        response.mail = address.address;\n      }\n\n      if (Object.keys(response).length) {\n        return response;\n      }\n\n      return false;\n    }).filter(address => address);\n\n    if (data.length) {\n      return {\n        [key]: response\n      };\n    }\n\n    return false;\n  }\n\n  parsePriority(value) {\n    value = value.toLowerCase().trim();\n\n    if (!isNaN(parseInt(value, 10))) {\n      // support \"X-Priority: 1 (Highest)\"\n      value = parseInt(value, 10) || 0;\n\n      if (value === 3) {\n        return 'normal';\n      } else if (value > 3) {\n        return 'low';\n      } else {\n        return 'high';\n      }\n    } else {\n      switch (value) {\n        case 'non-urgent':\n        case 'low':\n          return 'low';\n\n        case 'urgent':\n        case 'high':\n          return 'high';\n      }\n    }\n\n    return 'normal';\n  }\n\n  ensureMessageIDFormat(value) {\n    if (!value.length) {\n      return false;\n    }\n\n    if (value.charAt(0) !== '<') {\n      value = '<' + value;\n    }\n\n    if (value.charAt(value.length - 1) !== '>') {\n      value += '>';\n    }\n\n    return value;\n  }\n\n  decodeAddresses(addresses) {\n    for (let i = 0; i < addresses.length; i++) {\n      let address = addresses[i];\n      address.name = (address.name || '').toString().trim();\n\n      if (!address.address && /^(=\\?([^?]+)\\?[Bb]\\?[^?]*\\?=)(\\s*=\\?([^?]+)\\?[Bb]\\?[^?]*\\?=)*$/.test(address.name)) {\n        let parsed = addressparser(this.libmime.decodeWords(address.name));\n\n        if (parsed.length) {\n          parsed.forEach(entry => addresses.push(entry));\n        } // remove current element\n\n\n        addresses.splice(i, 1);\n        i--;\n        continue;\n      }\n\n      if (address.name) {\n        try {\n          address.name = this.libmime.decodeWords(address.name);\n        } catch (E) {//ignore, keep as is\n        }\n      }\n\n      if (/@xn--/.test(address.address)) {\n        address.address = address.address.substr(0, address.address.lastIndexOf('@') + 1) + punycode.toUnicode(address.address.substr(address.address.lastIndexOf('@') + 1));\n      }\n\n      if (address.group) {\n        this.decodeAddresses(address.group);\n      }\n    }\n  }\n\n  createNode(node) {\n    let contentType = node.contentType;\n    let disposition = node.disposition;\n    let encoding = node.encoding;\n    let charset = node.charset;\n\n    if (!contentType && node.root) {\n      contentType = 'text/plain';\n    }\n\n    let newNode = {\n      node,\n      headerLines: node.headers.lines,\n      headers: this.processHeaders(node.headers.getList()),\n      contentType,\n      children: []\n    };\n\n    if (!/^multipart\\//i.test(contentType)) {\n      if (disposition && !['attachment', 'inline'].includes(disposition)) {\n        disposition = 'attachment';\n      }\n\n      if (!disposition && !['text/plain', 'text/html'].includes(contentType)) {\n        newNode.disposition = 'attachment';\n      } else {\n        newNode.disposition = disposition || 'inline';\n      }\n\n      newNode.isAttachment = !['text/plain', 'text/html'].includes(contentType) || newNode.disposition !== 'inline';\n      newNode.encoding = ['quoted-printable', 'base64'].includes(encoding) ? encoding : 'binary';\n\n      if (charset) {\n        newNode.charset = charset;\n      }\n\n      let decoder = node.getDecoder();\n      decoder.on('end', () => {\n        this.decoderEnded = true;\n      });\n      newNode.decoder = decoder;\n    }\n\n    if (node.root) {\n      this.headers = newNode.headers;\n      this.headerLines = newNode.headerLines;\n    } // find location in tree\n\n\n    if (!this.tree) {\n      newNode.root = true;\n      this.curnode = this.tree = newNode;\n      return newNode;\n    } // immediate child of root node\n\n\n    if (!this.curnode.parent) {\n      newNode.parent = this.curnode;\n      this.curnode.children.push(newNode);\n      this.curnode = newNode;\n      return newNode;\n    } // siblings\n\n\n    if (this.curnode.parent.node === node.parentNode) {\n      newNode.parent = this.curnode.parent;\n      this.curnode.parent.children.push(newNode);\n      this.curnode = newNode;\n      return newNode;\n    } // first child\n\n\n    if (this.curnode.node === node.parentNode) {\n      newNode.parent = this.curnode;\n      this.curnode.children.push(newNode);\n      this.curnode = newNode;\n      return newNode;\n    } // move up\n\n\n    let parentNode = this.curnode;\n\n    while (parentNode = parentNode.parent) {\n      if (parentNode.node === node.parentNode) {\n        newNode.parent = parentNode;\n        parentNode.children.push(newNode);\n        this.curnode = newNode;\n        return newNode;\n      }\n    } // should never happen, can't detect parent\n\n\n    this.curnode = newNode;\n    return newNode;\n  }\n\n  getTextContent() {\n    let text = [];\n    let html = [];\n\n    let processNode = (alternative, level, node) => {\n      if (node.showMeta) {\n        let meta = ['From', 'Subject', 'Date', 'To', 'Cc', 'Bcc'].map(fkey => {\n          let key = fkey.toLowerCase();\n\n          if (!node.headers.has(key)) {\n            return false;\n          }\n\n          let value = node.headers.get(key);\n\n          if (!value) {\n            return false;\n          }\n\n          return {\n            key: fkey,\n            value: Array.isArray(value) ? value[value.length - 1] : value\n          };\n        }).filter(entry => entry);\n\n        if (this.hasHtml) {\n          html.push('<table class=\"mp_head\">' + meta.map(entry => {\n            let value = entry.value;\n\n            switch (entry.key) {\n              case 'From':\n              case 'To':\n              case 'Cc':\n              case 'Bcc':\n                value = value.html;\n                break;\n\n              case 'Date':\n                value = this.options.formatDateString ? this.options.formatDateString(value) : value.toUTCString();\n                break;\n\n              case 'Subject':\n                value = '<strong>' + he.encode(value) + '</strong>';\n                break;\n\n              default:\n                value = he.encode(value);\n            }\n\n            return '<tr><td class=\"mp_head_key\">' + he.encode(entry.key) + ':</td><td class=\"mp_head_value\">' + value + '<td></tr>';\n          }).join('\\n') + '<table>');\n        }\n\n        if (this.hasText) {\n          text.push('\\n' + meta.map(entry => {\n            let value = entry.value;\n\n            switch (entry.key) {\n              case 'From':\n              case 'To':\n              case 'Cc':\n              case 'Bcc':\n                value = value.text;\n                break;\n\n              case 'Date':\n                value = this.options.formatDateString ? this.options.formatDateString(value) : value.toUTCString();\n                break;\n            }\n\n            return entry.key + ': ' + value;\n          }).join('\\n') + '\\n');\n        }\n      }\n\n      if (node.textContent) {\n        if (node.contentType === 'text/plain') {\n          text.push(node.textContent);\n\n          if (!alternative && this.hasHtml) {\n            html.push(this.textToHtml(node.textContent));\n          }\n        } else if (node.contentType === 'text/html') {\n          let failedToParseHtml = false;\n\n          if (!alternative && this.hasText || node.root && !this.hasText) {\n            if (this.options.skipHtmlToText) {\n              text.push('');\n            } else if (node.textContent.length > this.options.maxHtmlLengthToParse) {\n              this.emit('error', new Error(`HTML too long for parsing ${node.textContent.length} bytes`));\n              text.push('Invalid HTML content (too long)');\n              failedToParseHtml = true;\n            } else {\n              try {\n                text.push(htmlToText.fromString(node.textContent));\n              } catch (err) {\n                this.emit('error', new Error('Failed to parse HTML'));\n                text.push('Invalid HTML content');\n                failedToParseHtml = true;\n              }\n            }\n          }\n\n          if (!failedToParseHtml) {\n            html.push(node.textContent);\n          }\n        }\n      }\n\n      alternative = alternative || node.contentType === 'multipart/alternative';\n      node.children.forEach(subNode => {\n        processNode(alternative, level + 1, subNode);\n      });\n    };\n\n    processNode(false, 0, this.tree);\n    let response = {\n      type: 'text'\n    };\n\n    if (html.length) {\n      this.html = response.html = html.join('<br/>\\n');\n    }\n\n    if (text.length) {\n      this.text = response.text = text.join('\\n');\n      this.textAsHtml = response.textAsHtml = text.map(part => this.textToHtml(part)).join('<br/>\\n');\n    }\n\n    return response;\n  }\n\n  processChunk(data, done) {\n    let partId = null;\n\n    if (data._parentBoundary) {\n      partId = this._getPartId(data._parentBoundary);\n    }\n\n    switch (data.type) {\n      case 'node':\n        {\n          let node = this.createNode(data);\n\n          if (node === this.tree) {\n            ['subject', 'references', 'date', 'to', 'from', 'to', 'cc', 'bcc', 'message-id', 'in-reply-to', 'reply-to'].forEach(key => {\n              if (node.headers.has(key)) {\n                this[key.replace(/-([a-z])/g, (m, c) => c.toUpperCase())] = node.headers.get(key);\n              }\n            });\n            this.emit('headers', node.headers);\n          }\n\n          if (data.contentType === 'message/rfc822' && data.messageNode) {\n            break;\n          }\n\n          if (data.parentNode && data.parentNode.contentType === 'message/rfc822') {\n            node.showMeta = true;\n          }\n\n          if (node.isAttachment) {\n            let contentType = node.contentType;\n\n            if (node.contentType === 'application/octet-stream' && data.filename) {\n              contentType = this.libmime.detectMimeType(data.filename) || 'application/octet-stream';\n            }\n\n            let attachment = {\n              type: 'attachment',\n              content: null,\n              contentType,\n              partId,\n              release: () => {\n                attachment.release = null;\n\n                if (this.waitUntilAttachmentEnd && typeof this.attachmentCallback === 'function') {\n                  setImmediate(this.attachmentCallback);\n                }\n\n                this.attachmentCallback = false;\n                this.waitUntilAttachmentEnd = false;\n              }\n            };\n            let hasher = new StreamHash(attachment, 'md5');\n            node.decoder.on('error', err => {\n              hasher.emit('error', err);\n            });\n            node.decoder.on('readable', () => {\n              let chunk;\n\n              while ((chunk = node.decoder.read()) !== null) {\n                hasher.write(chunk);\n              }\n            });\n            node.decoder.once('end', () => {\n              hasher.end();\n            }); //node.decoder.pipe(hasher);\n\n            attachment.content = hasher;\n            this.waitUntilAttachmentEnd = true;\n\n            if (data.disposition) {\n              attachment.contentDisposition = data.disposition;\n            }\n\n            if (data.filename) {\n              attachment.filename = data.filename;\n            }\n\n            if (node.headers.has('content-id')) {\n              attachment.contentId = [].concat(node.headers.get('content-id') || []).shift();\n              attachment.cid = attachment.contentId.trim().replace(/^<|>$/g, '').trim(); // check if the attachment is \"related\" to text content like an embedded image etc\n\n              let parentNode = node;\n\n              while (parentNode = parentNode.parent) {\n                if (parentNode.contentType === 'multipart/related') {\n                  attachment.related = true;\n                }\n              }\n            }\n\n            attachment.headers = node.headers;\n            this.push(attachment);\n            this.attachmentList.push(attachment);\n          } else if (node.disposition === 'inline') {\n            let chunks = [];\n            let chunklen = 0;\n            node.contentStream = node.decoder;\n\n            if (node.contentType === 'text/plain') {\n              this.hasText = true;\n            } else if (node.contentType === 'text/html') {\n              this.hasHtml = true;\n            }\n\n            if (node.node.flowed) {\n              let contentStream = node.contentStream;\n              let flowDecoder = new FlowedDecoder({\n                delSp: node.node.delSp\n              });\n              contentStream.on('error', err => {\n                flowDecoder.emit('error', err);\n              });\n              contentStream.pipe(flowDecoder);\n              node.contentStream = flowDecoder;\n            }\n\n            let charset = node.charset || 'utf-8'; //charset = charset || 'windows-1257';\n\n            if (!['ascii', 'usascii', 'utf8'].includes(charset.toLowerCase().replace(/[^a-z0-9]+/g, ''))) {\n              try {\n                let contentStream = node.contentStream;\n                let decodeStream = this.decoder.decodeStream(charset);\n                contentStream.on('error', err => {\n                  decodeStream.emit('error', err);\n                });\n                contentStream.pipe(decodeStream);\n                node.contentStream = decodeStream;\n              } catch (E) {// do not decode charset\n              }\n            }\n\n            node.contentStream.on('readable', () => {\n              let chunk;\n\n              while ((chunk = node.contentStream.read()) !== null) {\n                if (typeof chunk === 'string') {\n                  chunk = Buffer.from(chunk);\n                }\n\n                chunks.push(chunk);\n                chunklen += chunk.length;\n              }\n            });\n            node.contentStream.once('end', () => {\n              node.textContent = Buffer.concat(chunks, chunklen).toString().replace(/\\r?\\n/g, '\\n');\n            });\n            node.contentStream.once('error', err => {\n              this.emit('error', err);\n            });\n          }\n\n          break;\n        }\n\n      case 'data':\n        if (this.curnode && this.curnode.decoder) {\n          this.curnode.decoder.end();\n        }\n\n        if (this.waitUntilAttachmentEnd) {\n          this.attachmentCallback = done;\n          return;\n        } // multipart message structure\n        // this is not related to any specific 'node' block as it includes\n        // everything between the end of some node body and between the next header\n        //process.stdout.write(data.value);\n\n\n        break;\n\n      case 'body':\n        if (this.curnode && this.curnode.decoder && this.curnode.decoder.writable) {\n          if (this.curnode.decoder.write(data.value) === false) {\n            return this.curnode.decoder.once('drain', done);\n          }\n        } // Leaf element body. Includes the body for the last 'node' block. You might\n        // have several 'body' calls for a single 'node' block\n        //process.stdout.write(data.value);\n\n\n        break;\n    }\n\n    setImmediate(done);\n  }\n\n  _getPartId(parentBoundary) {\n    let boundaryIndex = this.boundaries.findIndex(item => item.name === parentBoundary);\n\n    if (boundaryIndex === -1) {\n      this.boundaries.push({\n        name: parentBoundary,\n        count: 1\n      });\n      boundaryIndex = this.boundaries.length - 1;\n    } else {\n      this.boundaries[boundaryIndex].count++;\n    }\n\n    let partId = '1';\n\n    for (let i = 0; i <= boundaryIndex; i++) {\n      if (i === 0) partId = this.boundaries[i].count.toString();else partId += '.' + this.boundaries[i].count.toString();\n    }\n\n    return partId;\n  }\n\n  getAddressesHTML(value) {\n    let formatSingleLevel = addresses => addresses.map(address => {\n      let str = '<span class=\"mp_address_group\">';\n\n      if (address.name) {\n        str += '<span class=\"mp_address_name\">' + he.encode(address.name) + (address.group ? ': ' : '') + '</span>';\n      }\n\n      if (address.address) {\n        let link = '<a href=\"mailto:' + he.encode(address.address) + '\" class=\"mp_address_email\">' + he.encode(address.address) + '</a>';\n\n        if (address.name) {\n          str += ' &lt;' + link + '&gt;';\n        } else {\n          str += link;\n        }\n      }\n\n      if (address.group) {\n        str += formatSingleLevel(address.group) + ';';\n      }\n\n      return str + '</span>';\n    }).join(', ');\n\n    return formatSingleLevel([].concat(value || []));\n  }\n\n  getAddressesText(value) {\n    let formatSingleLevel = addresses => addresses.map(address => {\n      let str = '';\n\n      if (address.name) {\n        str += address.name + (address.group ? ': ' : '');\n      }\n\n      if (address.address) {\n        let link = address.address;\n\n        if (address.name) {\n          str += ' <' + link + '>';\n        } else {\n          str += link;\n        }\n      }\n\n      if (address.group) {\n        str += formatSingleLevel(address.group) + ';';\n      }\n\n      return str;\n    }).join(', ');\n\n    return formatSingleLevel([].concat(value || []));\n  }\n\n  updateImageLinks(replaceCallback, done) {\n    if (!this.html) {\n      return setImmediate(() => done(null, false));\n    }\n\n    let cids = new Map();\n    let html = (this.html || '').toString();\n\n    if (this.options.skipImageLinks) {\n      return done(null, html);\n    }\n\n    html.replace(/\\bcid:([^'\"\\s]{1,256})/g, (match, cid) => {\n      for (let i = 0, len = this.attachmentList.length; i < len; i++) {\n        if (this.attachmentList[i].cid === cid && /^image\\/[\\w]+$/i.test(this.attachmentList[i].contentType)) {\n          if (/^image\\/[\\w]+$/i.test(this.attachmentList[i].contentType)) {\n            cids.set(cid, {\n              attachment: this.attachmentList[i]\n            });\n          }\n\n          break;\n        }\n      }\n\n      return match;\n    });\n    let cidList = [];\n    cids.forEach(entry => {\n      cidList.push(entry);\n    });\n    let pos = 0;\n\n    let processNext = () => {\n      if (pos >= cidList.length) {\n        html = html.replace(/\\bcid:([^'\"\\s]{1,256})/g, (match, cid) => {\n          if (cids.has(cid) && cids.get(cid).url) {\n            return cids.get(cid).url;\n          }\n\n          return match;\n        });\n        return done(null, html);\n      }\n\n      let entry = cidList[pos++];\n      replaceCallback(entry.attachment, (err, url) => {\n        if (err) {\n          return setImmediate(() => done(err));\n        }\n\n        entry.url = url;\n        setImmediate(processNext);\n      });\n    };\n\n    setImmediate(processNext);\n  }\n\n  textToHtml(str) {\n    if (this.options.skipTextToHtml) {\n      return '';\n    }\n\n    str = (str || '').toString();\n    let encoded;\n    let linkified = false;\n\n    if (!this.options.skipTextLinks) {\n      try {\n        if (linkify.pretest(str)) {\n          linkified = true;\n          let links = linkify.match(str) || [];\n          let result = [];\n          let last = 0;\n          links.forEach(link => {\n            if (last < link.index) {\n              let textPart = he // encode special chars\n              .encode(str.slice(last, link.index), {\n                useNamedReferences: true\n              });\n              result.push(textPart);\n            }\n\n            result.push(`<a href=\"${link.url}\">${link.text}</a>`);\n            last = link.lastIndex;\n          });\n          let textPart = he // encode special chars\n          .encode(str.slice(last), {\n            useNamedReferences: true\n          });\n          result.push(textPart);\n          encoded = result.join('');\n        }\n      } catch (E) {// failed, don't linkify\n      }\n    }\n\n    if (!linkified) {\n      encoded = he // encode special chars\n      .encode(str, {\n        useNamedReferences: true\n      });\n    }\n\n    let text = '<p>' + encoded.replace(/\\r?\\n/g, '\\n').trim() // normalize line endings\n    .replace(/[ \\t]+$/gm, '').trim() // trim empty line endings\n    .replace(/\\n\\n+/g, '</p><p>').trim() // insert <p> to multiple linebreaks\n    .replace(/\\n/g, '<br/>') + // insert <br> to single linebreaks\n    '</p>';\n    return text;\n  }\n\n}\n\nmodule.exports = MailParser;","map":null,"metadata":{},"sourceType":"script"}