{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/bhavik/Downloads/Cognisun/Evolution/Evolution_React/evolution_new/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/bhavik/Downloads/Cognisun/Evolution/Evolution_React/evolution_new/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/bhavik/Downloads/Cognisun/Evolution/Evolution_React/evolution_new/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/bhavik/Downloads/Cognisun/Evolution/Evolution_React/evolution_new/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar stream = require('stream');\n\nvar Transform = stream.Transform;\n/**\n * Encodes a Buffer into a base64 encoded string\n *\n * @param {Buffer} buffer Buffer to convert\n * @returns {String} base64 encoded string\n */\n\nfunction encode(buffer) {\n  if (typeof buffer === 'string') {\n    buffer = Buffer.from(buffer, 'utf-8');\n  }\n\n  return buffer.toString('base64');\n}\n/**\n * Decodes a base64 encoded string to a Buffer object\n *\n * @param {String} str base64 encoded string\n * @returns {Buffer} Decoded value\n */\n\n\nfunction decode(str) {\n  str = str || '';\n  return Buffer.from(str, 'base64');\n}\n/**\n * Adds soft line breaks to a base64 string\n *\n * @param {String} str base64 encoded string that might need line wrapping\n * @param {Number} [lineLength=76] Maximum allowed length for a line\n * @returns {String} Soft-wrapped base64 encoded string\n */\n\n\nfunction wrap(str, lineLength) {\n  str = (str || '').toString();\n  lineLength = lineLength || 76;\n\n  if (str.length <= lineLength) {\n    return str;\n  }\n\n  var result = [];\n  var pos = 0;\n  var chunkLength = lineLength * 1024;\n\n  while (pos < str.length) {\n    var wrappedLines = str.substr(pos, chunkLength).replace(new RegExp('.{' + lineLength + '}', 'g'), '$&\\r\\n').trim();\n    result.push(wrappedLines);\n    pos += chunkLength;\n  }\n\n  return result.join('\\r\\n').trim();\n}\n/**\n * Creates a transform stream for encoding data to base64 encoding\n *\n * @constructor\n * @param {Object} options Stream options\n * @param {Number} [options.lineLength=76] Maximum lenght for lines, set to false to disable wrapping\n */\n\n\nvar Encoder = /*#__PURE__*/function (_Transform) {\n  _inherits(Encoder, _Transform);\n\n  var _super = _createSuper(Encoder);\n\n  function Encoder(options) {\n    var _this;\n\n    _classCallCheck(this, Encoder);\n\n    _this = _super.call(this); // init Transform\n\n    _this.options = options || {};\n\n    if (_this.options.lineLength !== false) {\n      _this.options.lineLength = Number(_this.options.lineLength) || 76;\n    }\n\n    _this.skipStartBytes = Number(_this.options.skipStartBytes) || 0;\n    _this.limitOutbutBytes = Number(_this.options.limitOutbutBytes) || 0; // startPadding can be used together with skipStartBytes\n\n    _this._curLine = _this.options.startPadding || '';\n    _this._remainingBytes = false;\n    _this.inputBytes = 0;\n    _this.outputBytes = 0;\n    return _this;\n  }\n\n  _createClass(Encoder, [{\n    key: \"_writeChunk\",\n    value: function _writeChunk(chunk\n    /*, isFinal */\n    ) {\n      if (this.skipStartBytes) {\n        if (chunk.length <= this.skipStartBytes) {\n          this.skipStartBytes -= chunk.length;\n          return;\n        }\n\n        chunk = chunk.slice(this.skipStartBytes);\n        this.skipStartBytes = 0;\n      }\n\n      if (this.limitOutbutBytes) {\n        if (this.outputBytes + chunk.length <= this.limitOutbutBytes) {// ignore, can use entire chunk\n        } else if (this.outputBytes >= this.limitOutbutBytes) {\n          // chunks already processed\n          return;\n        } else {\n          // use partial chunk\n          chunk = chunk.slice(0, this.limitOutbutBytes - this.outputBytes);\n        }\n      }\n\n      this.outputBytes += chunk.length;\n      this.push(chunk);\n    }\n  }, {\n    key: \"_getWrapped\",\n    value: function _getWrapped(str, isFinal) {\n      str = wrap(str, this.options.lineLength);\n\n      if (!isFinal && str.length === this.options.lineLength) {\n        str += '\\r\\n';\n      }\n\n      return str;\n    }\n  }, {\n    key: \"_transform\",\n    value: function _transform(chunk, encoding, done) {\n      if (encoding !== 'buffer') {\n        chunk = Buffer.from(chunk, encoding);\n      }\n\n      if (!chunk || !chunk.length) {\n        return setImmediate(done);\n      }\n\n      this.inputBytes += chunk.length;\n\n      if (this._remainingBytes && this._remainingBytes.length) {\n        chunk = Buffer.concat([this._remainingBytes, chunk], this._remainingBytes.length + chunk.length);\n        this._remainingBytes = false;\n      }\n\n      if (chunk.length % 3) {\n        this._remainingBytes = chunk.slice(chunk.length - chunk.length % 3);\n        chunk = chunk.slice(0, chunk.length - chunk.length % 3);\n      } else {\n        this._remainingBytes = false;\n      }\n\n      var b64 = this._curLine + encode(chunk);\n\n      if (this.options.lineLength) {\n        b64 = this._getWrapped(b64); // remove last line as it is still most probably incomplete\n\n        var lastLF = b64.lastIndexOf('\\n');\n\n        if (lastLF < 0) {\n          this._curLine = b64;\n          b64 = '';\n        } else if (lastLF === b64.length - 1) {\n          this._curLine = '';\n        } else {\n          this._curLine = b64.substr(lastLF + 1);\n          b64 = b64.substr(0, lastLF + 1);\n        }\n      }\n\n      if (b64) {\n        this._writeChunk(Buffer.from(b64, 'ascii'), false);\n      }\n\n      setImmediate(done);\n    }\n  }, {\n    key: \"_flush\",\n    value: function _flush(done) {\n      if (this._remainingBytes && this._remainingBytes.length) {\n        this._curLine += encode(this._remainingBytes);\n      }\n\n      if (this._curLine) {\n        this._curLine = this._getWrapped(this._curLine, true);\n\n        this._writeChunk(Buffer.from(this._curLine, 'ascii'), true);\n\n        this._curLine = '';\n      }\n\n      done();\n    }\n  }]);\n\n  return Encoder;\n}(Transform);\n/**\n * Creates a transform stream for decoding base64 encoded strings\n *\n * @constructor\n * @param {Object} options Stream options\n */\n\n\nvar Decoder = /*#__PURE__*/function (_Transform2) {\n  _inherits(Decoder, _Transform2);\n\n  var _super2 = _createSuper(Decoder);\n\n  function Decoder(options) {\n    var _this2;\n\n    _classCallCheck(this, Decoder);\n\n    _this2 = _super2.call(this); // init Transform\n\n    _this2.options = options || {};\n    _this2._curLine = '';\n    _this2.inputBytes = 0;\n    _this2.outputBytes = 0;\n    return _this2;\n  }\n\n  _createClass(Decoder, [{\n    key: \"_transform\",\n    value: function _transform(chunk, encoding, done) {\n      if (!chunk || !chunk.length) {\n        return setImmediate(done);\n      }\n\n      this.inputBytes += chunk.length;\n      var b64 = this._curLine + chunk.toString('ascii');\n      this._curLine = '';\n\n      if (/[^a-zA-Z0-9+/=]/.test(b64)) {\n        b64 = b64.replace(/[^a-zA-Z0-9+/=]/g, '');\n      }\n\n      if (b64.length < 4) {\n        this._curLine = b64;\n        b64 = '';\n      } else if (b64.length % 4) {\n        this._curLine = b64.substr(-b64.length % 4);\n        b64 = b64.substr(0, b64.length - this._curLine.length);\n      }\n\n      if (b64) {\n        var buf = decode(b64);\n        this.outputBytes += buf.length;\n        this.push(buf);\n      }\n\n      setImmediate(done);\n    }\n  }, {\n    key: \"_flush\",\n    value: function _flush(done) {\n      if (this._curLine) {\n        var buf = decode(this._curLine);\n        this.outputBytes += buf.length;\n        this.push(buf);\n        this._curLine = '';\n      }\n\n      setImmediate(done);\n    }\n  }]);\n\n  return Decoder;\n}(Transform); // expose to the world\n\n\nmodule.exports = {\n  encode: encode,\n  decode: decode,\n  wrap: wrap,\n  Encoder: Encoder,\n  Decoder: Decoder\n};","map":null,"metadata":{},"sourceType":"script"}