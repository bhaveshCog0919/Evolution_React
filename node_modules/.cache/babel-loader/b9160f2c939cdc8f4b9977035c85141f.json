{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/bhavik/Downloads/Cognisun/Evolution/Evolution_React/evolution_new/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/bhavik/Downloads/Cognisun/Evolution/Evolution_React/evolution_new/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar Headers = require('./headers');\n\nvar libmime = require('libmime');\n\nvar libqp = require('libqp');\n\nvar libbase64 = require('libbase64');\n\nvar PassThrough = require('stream').PassThrough;\n\nvar MimeNode = /*#__PURE__*/function () {\n  function MimeNode(parentNode, config) {\n    _classCallCheck(this, MimeNode);\n\n    this.type = 'node';\n    this.root = !parentNode;\n    this.parentNode = parentNode;\n    this._parentBoundary = this.parentNode && this.parentNode._boundary;\n    this._headersLines = [];\n    this._headerlen = 0;\n    this._parsedContentType = false;\n    this._boundary = false;\n    this.multipart = false;\n    this.encoding = false;\n    this.headers = false;\n    this.contentType = false;\n    this.flowed = false;\n    this.delSp = false;\n    this.config = config || {};\n    this.libmime = new libmime.Libmime({\n      Iconv: this.config.Iconv\n    });\n    this.parentPartNumber = parentNode && this.partNr || [];\n    this.partNr = false; // resolved later\n\n    this.childPartNumbers = 0;\n  }\n\n  _createClass(MimeNode, [{\n    key: \"getPartNr\",\n    value: function getPartNr(provided) {\n      if (provided) {\n        return [].concat(this.partNr || []).filter(function (nr) {\n          return !isNaN(nr);\n        }).concat(provided);\n      }\n\n      var childPartNr = ++this.childPartNumbers;\n      return [].concat(this.partNr || []).filter(function (nr) {\n        return !isNaN(nr);\n      }).concat(childPartNr);\n    }\n  }, {\n    key: \"addHeaderChunk\",\n    value: function addHeaderChunk(line) {\n      if (!line) {\n        return;\n      }\n\n      this._headersLines.push(line);\n\n      this._headerlen += line.length;\n    }\n  }, {\n    key: \"parseHeaders\",\n    value: function parseHeaders() {\n      if (this.headers) {\n        return;\n      }\n\n      this.headers = new Headers(Buffer.concat(this._headersLines, this._headerlen), this.config);\n      this._parsedContentType = this.libmime.parseHeaderValue(this.headers.getFirst('Content-Type'));\n      this._parsedContentDisposition = this.libmime.parseHeaderValue(this.headers.getFirst('Content-Disposition'));\n      this.encoding = this.headers.getFirst('Content-Transfer-Encoding').replace(/\\(.*\\)/g, '').toLowerCase().trim();\n      this.contentType = (this._parsedContentType.value || '').toLowerCase().trim() || false;\n      this.charset = this._parsedContentType.params.charset || false;\n      this.disposition = (this._parsedContentDisposition.value || '').toLowerCase().trim() || false; // fix invalidly encoded disposition values\n\n      if (this.disposition) {\n        try {\n          this.disposition = this.libmime.decodeWords(this.disposition);\n        } catch (E) {// failed to parse disposition, keep as is (most probably an unknown charset is used)\n        }\n      }\n\n      this.filename = this._parsedContentDisposition.params.filename || this._parsedContentType.params.name || false;\n\n      if (this._parsedContentType.params.format && this._parsedContentType.params.format.toLowerCase().trim() === 'flowed') {\n        this.flowed = true;\n\n        if (this._parsedContentType.params.delsp && this._parsedContentType.params.delsp.toLowerCase().trim() === 'yes') {\n          this.delSp = true;\n        }\n      }\n\n      if (this.filename) {\n        try {\n          this.filename = this.libmime.decodeWords(this.filename);\n        } catch (E) {// failed to parse filename, keep as is (most probably an unknown charset is used)\n        }\n      }\n\n      this.multipart = this.contentType && this.contentType.substr(0, this.contentType.indexOf('/')) === 'multipart' && this.contentType.substr(this.contentType.indexOf('/') + 1) || false;\n      this._boundary = this._parsedContentType.params.boundary && Buffer.from(this._parsedContentType.params.boundary) || false;\n      this.rfc822 = this.contentType === 'message/rfc822';\n\n      if (!this.parentNode || this.parentNode.rfc822) {\n        this.partNr = this.parentNode ? this.parentNode.getPartNr('TEXT') : ['TEXT'];\n      } else {\n        this.partNr = this.parentNode ? this.parentNode.getPartNr() : [];\n      }\n    }\n  }, {\n    key: \"getHeaders\",\n    value: function getHeaders() {\n      if (!this.headers) {\n        this.parseHeaders();\n      }\n\n      return this.headers.build();\n    }\n  }, {\n    key: \"setContentType\",\n    value: function setContentType(contentType) {\n      if (!this.headers) {\n        this.parseHeaders();\n      }\n\n      contentType = (contentType || '').toLowerCase().trim();\n\n      if (contentType) {\n        this._parsedContentType.value = contentType;\n      }\n\n      if (!this.flowed && this._parsedContentType.params.format) {\n        delete this._parsedContentType.params.format;\n      }\n\n      if (!this.delSp && this._parsedContentType.params.delsp) {\n        delete this._parsedContentType.params.delsp;\n      }\n\n      this.headers.update('Content-Type', this.libmime.buildHeaderValue(this._parsedContentType));\n    }\n  }, {\n    key: \"setCharset\",\n    value: function setCharset(charset) {\n      if (!this.headers) {\n        this.parseHeaders();\n      }\n\n      charset = (charset || '').toLowerCase().trim();\n\n      if (charset === 'ascii') {\n        charset = '';\n      }\n\n      if (!charset) {\n        if (!this._parsedContentType.value) {\n          // nothing to set or update\n          return;\n        }\n\n        delete this._parsedContentType.params.charset;\n      } else {\n        this._parsedContentType.params.charset = charset;\n      }\n\n      if (!this._parsedContentType.value) {\n        this._parsedContentType.value = 'text/plain';\n      }\n\n      this.headers.update('Content-Type', this.libmime.buildHeaderValue(this._parsedContentType));\n    }\n  }, {\n    key: \"setFilename\",\n    value: function setFilename(filename) {\n      if (!this.headers) {\n        this.parseHeaders();\n      }\n\n      this.filename = (filename || '').toLowerCase().trim();\n\n      if (this._parsedContentType.params.name) {\n        delete this._parsedContentType.params.name;\n        this.headers.update('Content-Type', this.libmime.buildHeaderValue(this._parsedContentType));\n      }\n\n      if (!this.filename) {\n        if (!this._parsedContentDisposition.value) {\n          // nothing to set or update\n          return;\n        }\n\n        delete this._parsedContentDisposition.params.filename;\n      } else {\n        this._parsedContentDisposition.params.filename = this.filename;\n      }\n\n      if (!this._parsedContentDisposition.value) {\n        this._parsedContentDisposition.value = 'attachment';\n      }\n\n      this.headers.update('Content-Disposition', this.libmime.buildHeaderValue(this._parsedContentDisposition));\n    }\n  }, {\n    key: \"getDecoder\",\n    value: function getDecoder() {\n      if (!this.headers) {\n        this.parseHeaders();\n      }\n\n      switch (this.encoding) {\n        case 'base64':\n          return new libbase64.Decoder();\n\n        case 'quoted-printable':\n          return new libqp.Decoder();\n\n        default:\n          return new PassThrough();\n      }\n    }\n  }, {\n    key: \"getEncoder\",\n    value: function getEncoder(encoding) {\n      if (!this.headers) {\n        this.parseHeaders();\n      }\n\n      encoding = (encoding || '').toString().toLowerCase().trim();\n\n      if (encoding && encoding !== this.encoding) {\n        this.headers.update('Content-Transfer-Encoding', encoding);\n      } else {\n        encoding = this.encoding;\n      }\n\n      switch (encoding) {\n        case 'base64':\n          return new libbase64.Encoder();\n\n        case 'quoted-printable':\n          return new libqp.Encoder();\n\n        default:\n          return new PassThrough();\n      }\n    }\n  }]);\n\n  return MimeNode;\n}();\n\nmodule.exports = MimeNode;","map":null,"metadata":{},"sourceType":"script"}