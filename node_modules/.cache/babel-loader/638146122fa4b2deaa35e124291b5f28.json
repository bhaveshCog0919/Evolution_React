{"ast":null,"code":"'use strict'; // Helper class to rewrite nodes with specific mime type\n\nconst Transform = require('stream').Transform;\n\nconst libmime = require('libmime');\n/**\n * Really bad \"stream\" transform to parse format=flowed content\n *\n * @constructor\n * @param {String} delSp True if delsp option was used\n */\n\n\nclass FlowedDecoder extends Transform {\n  constructor(config) {\n    super();\n    this.config = config || {};\n    this.chunks = [];\n    this.chunklen = 0;\n    this.libmime = new libmime.Libmime({\n      Iconv: config.Iconv\n    });\n  }\n\n  _transform(chunk, encoding, callback) {\n    if (!chunk || !chunk.length) {\n      return callback();\n    }\n\n    if (!encoding !== 'buffer') {\n      chunk = Buffer.from(chunk, encoding);\n    }\n\n    this.chunks.push(chunk);\n    this.chunklen += chunk.length;\n    callback();\n  }\n\n  _flush(callback) {\n    if (this.chunklen) {\n      let currentBody = Buffer.concat(this.chunks, this.chunklen);\n\n      if (this.config.encoding === 'base64') {\n        currentBody = Buffer.from(currentBody.toString('binary'), 'base64');\n      }\n\n      let content = this.libmime.decodeFlowed(currentBody.toString('binary'), this.config.delSp);\n      this.push(Buffer.from(content, 'binary'));\n    }\n\n    return callback();\n  }\n\n}\n\nmodule.exports = FlowedDecoder;","map":null,"metadata":{},"sourceType":"script"}