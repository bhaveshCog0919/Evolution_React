{"ast":null,"code":"'use strict';\n\nconst libmime = require('libmime');\n/**\n * Class Headers to parse and handle message headers. Headers instance allows to\n * check existing, delete or add new headers\n */\n\n\nclass Headers {\n  constructor(headers, config) {\n    config = config || {};\n\n    if (Array.isArray(headers)) {\n      // already using parsed headers\n      this.changed = true;\n      this.headers = false;\n      this.parsed = true;\n      this.lines = headers;\n    } else {\n      // using original string/buffer headers\n      this.changed = false;\n      this.headers = headers;\n      this.parsed = false;\n      this.lines = false;\n    }\n\n    this.mbox = false;\n    this.http = false;\n    this.libmime = new libmime.Libmime({\n      Iconv: config.Iconv\n    });\n  }\n\n  hasHeader(key) {\n    if (!this.parsed) {\n      this._parseHeaders();\n    }\n\n    key = this._normalizeHeader(key);\n    return typeof this.lines.find(line => line.key === key) === 'object';\n  }\n\n  get(key) {\n    if (!this.parsed) {\n      this._parseHeaders();\n    }\n\n    key = this._normalizeHeader(key);\n    let lines = this.lines.filter(line => line.key === key).map(line => line.line);\n    return lines;\n  }\n\n  getDecoded(key) {\n    return this.get(key).map(line => this.libmime.decodeHeader(line)).filter(line => line && line.value);\n  }\n\n  getFirst(key) {\n    if (!this.parsed) {\n      this._parseHeaders();\n    }\n\n    key = this._normalizeHeader(key);\n    let header = this.lines.find(line => line.key === key);\n\n    if (!header) {\n      return '';\n    }\n\n    return ((this.libmime.decodeHeader(header.line) || {}).value || '').toString().trim();\n  }\n\n  getList() {\n    if (!this.parsed) {\n      this._parseHeaders();\n    }\n\n    return this.lines;\n  }\n\n  add(key, value, index) {\n    if (typeof value === 'undefined') {\n      return;\n    }\n\n    if (typeof value === 'number') {\n      value = value.toString();\n    }\n\n    if (typeof value === 'string') {\n      value = Buffer.from(value);\n    }\n\n    value = value.toString('binary');\n    this.addFormatted(key, this.libmime.foldLines(key + ': ' + value.replace(/\\r?\\n/g, ''), 76, false), index);\n  }\n\n  addFormatted(key, line, index) {\n    if (!this.parsed) {\n      this._parseHeaders();\n    }\n\n    index = index || 0;\n    this.changed = true;\n\n    if (!line) {\n      return;\n    }\n\n    if (typeof line !== 'string') {\n      line = line.toString('binary');\n    }\n\n    let header = {\n      key: this._normalizeHeader(key),\n      line\n    };\n\n    if (index < 1) {\n      this.lines.unshift(header);\n    } else if (index >= this.lines.length) {\n      this.lines.push(header);\n    } else {\n      this.lines.splice(index, 0, header);\n    }\n  }\n\n  remove(key) {\n    if (!this.parsed) {\n      this._parseHeaders();\n    }\n\n    key = this._normalizeHeader(key);\n\n    for (let i = this.lines.length - 1; i >= 0; i--) {\n      if (this.lines[i].key === key) {\n        this.changed = true;\n        this.lines.splice(i, 1);\n      }\n    }\n  }\n\n  update(key, value, relativeIndex) {\n    if (!this.parsed) {\n      this._parseHeaders();\n    }\n\n    let keyName = key;\n    let index = 0;\n    key = this._normalizeHeader(key);\n    let relativeIndexCount = 0;\n    let relativeMatchFound = false;\n\n    for (let i = this.lines.length - 1; i >= 0; i--) {\n      if (this.lines[i].key === key) {\n        if (relativeIndex && relativeIndex !== relativeIndexCount) {\n          relativeIndexCount++;\n          continue;\n        }\n\n        index = i;\n        this.changed = true;\n        this.lines.splice(i, 1);\n\n        if (relativeIndex) {\n          relativeMatchFound = true;\n          break;\n        }\n      }\n    }\n\n    if (relativeIndex && !relativeMatchFound) return;\n    this.add(keyName, value, index);\n  }\n\n  build(lineEnd) {\n    if (!this.changed && !lineEnd) {\n      return typeof this.headers === 'string' ? Buffer.from(this.headers, 'binary') : this.headers;\n    }\n\n    if (!this.parsed) {\n      this._parseHeaders();\n    }\n\n    lineEnd = lineEnd || '\\r\\n';\n    let headers = this.lines.map(line => line.line.replace(/\\r?\\n/g, lineEnd)).join(lineEnd) + `${lineEnd}${lineEnd}`;\n\n    if (this.mbox) {\n      headers = this.mbox + lineEnd + headers;\n    }\n\n    if (this.http) {\n      headers = this.http + lineEnd + headers;\n    }\n\n    return Buffer.from(headers, 'binary');\n  }\n\n  _normalizeHeader(key) {\n    return (key || '').toLowerCase().trim();\n  }\n\n  _parseHeaders() {\n    if (!this.headers) {\n      this.lines = [];\n      this.parsed = true;\n      return;\n    }\n\n    let lines = this.headers.toString('binary').replace(/[\\r\\n]+$/, '').split(/\\r?\\n/);\n\n    for (let i = lines.length - 1; i >= 0; i--) {\n      let chr = lines[i].charAt(0);\n\n      if (i && (chr === ' ' || chr === '\\t')) {\n        lines[i - 1] += '\\r\\n' + lines[i];\n        lines.splice(i, 1);\n      } else {\n        let line = lines[i];\n\n        if (!i && /^From /i.test(line)) {\n          // mbox file\n          this.mbox = line;\n          lines.splice(i, 1);\n          continue;\n        } else if (!i && /^POST /i.test(line)) {\n          // HTTP POST request\n          this.http = line;\n          lines.splice(i, 1);\n          continue;\n        }\n\n        let key = this._normalizeHeader(line.substr(0, line.indexOf(':')));\n\n        lines[i] = {\n          key,\n          line\n        };\n      }\n    }\n\n    this.lines = lines;\n    this.parsed = true;\n  }\n\n} // expose to the world\n\n\nmodule.exports = Headers;","map":null,"metadata":{},"sourceType":"script"}