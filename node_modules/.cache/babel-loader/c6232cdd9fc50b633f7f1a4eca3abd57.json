{"ast":null,"code":"'use strict';\n\nvar iconv = require('iconv-lite');\n\nvar encodingJapanese = require('encoding-japanese');\n\nvar charsets = require('./charsets');\n/**\n * Character set encoding and decoding functions\n */\n\n\nvar charset = module.exports = {\n  /**\n   * Encodes an unicode string into an Buffer object as UTF-8\n   *\n   * We force UTF-8 here, no strange encodings allowed.\n   *\n   * @param {String} str String to be encoded\n   * @return {Buffer} UTF-8 encoded typed array\n   */\n  encode: function encode(str) {\n    return Buffer.from(str, 'utf-8');\n  },\n\n  /**\n   * Decodes a string from Buffer to an unicode string using specified encoding\n   * NB! Throws if unknown charset is used\n   *\n   * @param {Buffer} buf Binary data to be decoded\n   * @param {String} [fromCharset='UTF-8'] Binary data is decoded into string using this charset\n   * @return {String} Decded string\n   */\n  decode: function decode(buf, fromCharset) {\n    fromCharset = charset.normalizeCharset(fromCharset || 'UTF-8');\n\n    if (/^(us-)?ascii|utf-8|7bit$/i.test(fromCharset)) {\n      return buf.toString('utf-8');\n    }\n\n    try {\n      if (/^jis|^iso-?2022-?jp|^EUCJP/i.test(fromCharset)) {\n        if (typeof buf === 'string') {\n          buf = Buffer.from(buf);\n        }\n\n        try {\n          var output = encodingJapanese.convert(buf, {\n            to: 'UNICODE',\n            from: fromCharset,\n            type: 'string'\n          });\n\n          if (typeof output === 'string') {\n            output = Buffer.from(output);\n          }\n\n          return output;\n        } catch (err) {// ignore, defaults to iconv-lite on error\n        }\n      }\n\n      return iconv.decode(buf, fromCharset);\n    } catch (err) {\n      // enforce utf-8, data loss might occur\n      return buf.toString();\n    }\n  },\n\n  /**\n   * Convert a string from specific encoding to UTF-8 Buffer\n   *\n   * @param {String|Buffer} str String to be encoded\n   * @param {String} [fromCharset='UTF-8'] Source encoding for the string\n   * @return {Buffer} UTF-8 encoded typed array\n   */\n  convert: function convert(data, fromCharset) {\n    fromCharset = charset.normalizeCharset(fromCharset || 'UTF-8');\n    var bufString;\n\n    if (typeof data !== 'string') {\n      if (/^(us-)?ascii|utf-8|7bit$/i.test(fromCharset)) {\n        return data;\n      }\n\n      bufString = charset.decode(data, fromCharset);\n      return charset.encode(bufString);\n    }\n\n    return charset.encode(data);\n  },\n\n  /**\n   * Converts well known invalid character set names to proper names.\n   * eg. win-1257 will be converted to WINDOWS-1257\n   *\n   * @param {String} charset Charset name to convert\n   * @return {String} Canoninicalized charset name\n   */\n  normalizeCharset: function normalizeCharset(charset) {\n    charset = charset.toLowerCase().trim(); // first pass\n\n    if (charsets.hasOwnProperty(charset) && charsets[charset]) {\n      return charsets[charset];\n    }\n\n    charset = charset.replace(/^utf[-_]?(\\d+)/, 'utf-$1').replace(/^(?:us[-_]?)ascii/, 'windows-1252').replace(/^win(?:dows)?[-_]?(\\d+)/, 'windows-$1').replace(/^(?:latin|iso[-_]?8859)?[-_]?(\\d+)/, 'iso-8859-$1').replace(/^l[-_]?(\\d+)/, 'iso-8859-$1'); // updated pass\n\n    if (charsets.hasOwnProperty(charset) && charsets[charset]) {\n      return charsets[charset];\n    }\n\n    return charset.toUpperCase();\n  }\n};","map":null,"metadata":{},"sourceType":"script"}