{"ast":null,"code":"'use strict'; // Helper class to rewrite nodes with specific mime type\n\nvar _classCallCheck = require(\"/Users/bhavik/Downloads/Cognisun/Evolution/Evolution_React/evolution_new/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/bhavik/Downloads/Cognisun/Evolution/Evolution_React/evolution_new/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/bhavik/Downloads/Cognisun/Evolution/Evolution_React/evolution_new/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/bhavik/Downloads/Cognisun/Evolution/Evolution_React/evolution_new/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar Transform = require('stream').Transform;\n\nvar FlowedDecoder = require('./flowed-decoder');\n/**\n * NodeRewriter Transform stream. Updates content for all nodes with specified mime type\n *\n * @constructor\n * @param {String} mimeType Define the Mime-Type to look for\n * @param {Function} streamAction Function to run with the node content\n */\n\n\nvar NodeStreamer = /*#__PURE__*/function (_Transform) {\n  _inherits(NodeStreamer, _Transform);\n\n  var _super = _createSuper(NodeStreamer);\n\n  function NodeStreamer(filterFunc, streamAction) {\n    var _this;\n\n    _classCallCheck(this, NodeStreamer);\n\n    var options = {\n      readableObjectMode: true,\n      writableObjectMode: true\n    };\n    _this = _super.call(this, options);\n    _this.filterFunc = filterFunc;\n    _this.streamAction = streamAction;\n    _this.decoder = false;\n    _this.canContinue = false;\n    _this.continue = false;\n    return _this;\n  }\n\n  _createClass(NodeStreamer, [{\n    key: \"_transform\",\n    value: function _transform(data, encoding, callback) {\n      this.processIncoming(data, callback);\n    }\n  }, {\n    key: \"_flush\",\n    value: function _flush(callback) {\n      if (this.decoder) {\n        // emit an empty node just in case there is pending data to end\n        return this.processIncoming({\n          type: 'none'\n        }, callback);\n      }\n\n      return callback();\n    }\n  }, {\n    key: \"processIncoming\",\n    value: function processIncoming(data, callback) {\n      var _this2 = this;\n\n      if (this.decoder && data.type === 'body') {\n        // data to parse\n        this.push(data);\n\n        if (!this.decoder.write(data.value)) {\n          return this.decoder.once('drain', callback);\n        } else {\n          return callback();\n        }\n      } else if (this.decoder && data.type !== 'body') {\n        // stop decoding.\n        // we can not process the current data chunk as we need to wait until\n        // the parsed data is completely processed, so we store a reference to the\n        // continue callback\n        var doContinue = function doContinue() {\n          _this2.continue = false;\n          _this2.decoder = false;\n          _this2.canContinue = false;\n\n          _this2.processIncoming(data, callback);\n        };\n\n        if (this.canContinue) {\n          setImmediate(doContinue);\n        } else {\n          this.continue = function () {\n            return doContinue();\n          };\n        }\n\n        return this.decoder.end();\n      } else if (data.type === 'node' && this.filterFunc(data)) {\n        this.push(data); // found matching node, create new handler\n\n        this.emit('node', this.createDecoder(data));\n      } else if (this.readable && data.type !== 'none') {\n        // we don't care about this data, just pass it over to the joiner\n        this.push(data);\n      }\n\n      callback();\n    }\n  }, {\n    key: \"createDecoder\",\n    value: function createDecoder(node) {\n      var _this3 = this;\n\n      this.decoder = node.getDecoder();\n      var decoder = this.decoder;\n      decoder.$reading = false;\n\n      if (/^text\\//.test(node.contentType) && node.flowed) {\n        var flowDecoder = decoder;\n        decoder = new FlowedDecoder({\n          delSp: node.delSp\n        });\n        flowDecoder.on('error', function (err) {\n          decoder.emit('error', err);\n        });\n        flowDecoder.pipe(decoder);\n      }\n\n      return {\n        node: node,\n        decoder: decoder,\n        done: function done() {\n          if (typeof _this3.continue === 'function') {\n            // called once input stream is processed\n            _this3.continue();\n          } else {\n            // called before input stream is processed\n            _this3.canContinue = true;\n          }\n        }\n      };\n    }\n  }]);\n\n  return NodeStreamer;\n}(Transform);\n\nmodule.exports = NodeStreamer;","map":null,"metadata":{},"sourceType":"script"}