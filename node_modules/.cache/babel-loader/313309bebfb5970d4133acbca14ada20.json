{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/bhavik/Downloads/Cognisun/Evolution/Evolution_React/evolution_new/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/bhavik/Downloads/Cognisun/Evolution/Evolution_React/evolution_new/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/bhavik/Downloads/Cognisun/Evolution/Evolution_React/evolution_new/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/bhavik/Downloads/Cognisun/Evolution/Evolution_React/evolution_new/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar Transform = require('stream').Transform;\n\nvar MimeNode = require('./mime-node');\n\nvar MAX_HEAD_SIZE = 1 * 1024 * 1024;\nvar MAX_CHILD_NODES = 1000;\nvar HEAD = 0x01;\nvar BODY = 0x02;\n\nvar MessageSplitter = /*#__PURE__*/function (_Transform) {\n  _inherits(MessageSplitter, _Transform);\n\n  var _super = _createSuper(MessageSplitter);\n\n  function MessageSplitter(config) {\n    var _this;\n\n    _classCallCheck(this, MessageSplitter);\n\n    var options = {\n      readableObjectMode: true,\n      writableObjectMode: false\n    };\n    _this = _super.call(this, options);\n    _this.config = config || {};\n    _this.maxHeadSize = _this.config.maxHeadSize || MAX_HEAD_SIZE;\n    _this.maxChildNodes = _this.config.maxChildNodes || MAX_CHILD_NODES;\n    _this.tree = [];\n    _this.nodeCounter = 0;\n\n    _this.newNode();\n\n    _this.tree.push(_this.node);\n\n    _this.line = false;\n    _this.errored = false;\n    return _this;\n  }\n\n  _createClass(MessageSplitter, [{\n    key: \"_transform\",\n    value: function _transform(chunk, encoding, callback) {\n      var _this2 = this;\n\n      // process line by line\n      // find next line ending\n      var pos = 0;\n      var i = 0;\n      var group = {\n        type: 'none'\n      };\n      var groupstart = this.line ? -this.line.length : 0;\n      var groupend = 0;\n\n      var checkTrailingLinebreak = function checkTrailingLinebreak(data) {\n        if (data.type === 'body' && data.node.parentNode && data.value && data.value.length) {\n          if (data.value[data.value.length - 1] === 0x0a) {\n            groupstart--;\n            groupend--;\n            pos--;\n\n            if (data.value.length > 1 && data.value[data.value.length - 2] === 0x0d) {\n              groupstart--;\n              groupend--;\n              pos--;\n\n              if (groupstart < 0 && !_this2.line) {\n                // store only <CR> as <LF> should be on the positive side\n                _this2.line = Buffer.allocUnsafe(1);\n                _this2.line[0] = 0x0d;\n              }\n\n              data.value = data.value.slice(0, data.value.length - 2);\n            } else {\n              data.value = data.value.slice(0, data.value.length - 1);\n            }\n          } else if (data.value[data.value.length - 1] === 0x0d) {\n            groupstart--;\n            groupend--;\n            pos--;\n            data.value = data.value.slice(0, data.value.length - 1);\n          }\n        }\n      };\n\n      var iterateData = function iterateData() {\n        for (var len = chunk.length; i < len; i++) {\n          // find next <LF>\n          if (chunk[i] === 0x0a) {\n            // line end\n            var start = Math.max(pos, 0);\n            pos = ++i;\n            return _this2.processLine(chunk.slice(start, i), false, function (err, data, flush) {\n              if (err) {\n                _this2.errored = true;\n                return setImmediate(function () {\n                  return callback(err);\n                });\n              }\n\n              if (!data) {\n                return setImmediate(iterateData);\n              }\n\n              if (flush) {\n                if (group && group.type !== 'none') {\n                  if (group.type === 'body' && groupend >= groupstart && group.node.parentNode) {\n                    // do not include the last line ending for body\n                    if (chunk[groupend - 1] === 0x0a) {\n                      groupend--;\n\n                      if (groupend >= groupstart && chunk[groupend - 1] === 0x0d) {\n                        groupend--;\n                      }\n                    }\n                  }\n\n                  if (groupstart !== groupend) {\n                    group.value = chunk.slice(groupstart, groupend);\n\n                    if (groupend < i) {\n                      data.value = chunk.slice(groupend, i);\n                    }\n                  }\n\n                  _this2.push(group);\n\n                  group = {\n                    type: 'none'\n                  };\n                  groupstart = groupend = i;\n                }\n\n                _this2.push(data);\n\n                groupend = i;\n                return setImmediate(iterateData);\n              }\n\n              if (data.type === group.type) {\n                // shift slice end position forward\n                groupend = i;\n              } else {\n                if (group.type === 'body' && groupend >= groupstart && group.node.parentNode) {\n                  // do not include the last line ending for body\n                  if (chunk[groupend - 1] === 0x0a) {\n                    groupend--;\n\n                    if (groupend >= groupstart && chunk[groupend - 1] === 0x0d) {\n                      groupend--;\n                    }\n                  }\n                }\n\n                if (group.type !== 'none' && group.type !== 'node') {\n                  // we have a previous data/body chunk to output\n                  if (groupstart !== groupend) {\n                    group.value = chunk.slice(groupstart, groupend);\n\n                    if (group.value && group.value.length) {\n                      _this2.push(group);\n\n                      group = {\n                        type: 'none'\n                      };\n                    }\n                  }\n                }\n\n                if (data.type === 'node') {\n                  _this2.push(data);\n\n                  groupstart = i;\n                  groupend = i;\n                } else if (groupstart < 0) {\n                  groupstart = i;\n                  groupend = i;\n                  checkTrailingLinebreak(data);\n\n                  if (data.value && data.value.length) {\n                    _this2.push(data);\n                  }\n                } else {\n                  // start new body/data chunk\n                  group = data;\n                  groupstart = groupend;\n                  groupend = i;\n                }\n              }\n\n              return setImmediate(iterateData);\n            });\n          }\n        } // skip last linebreak for body\n\n\n        if (pos >= groupstart + 1 && group.type === 'body' && group.node.parentNode) {\n          // do not include the last line ending for body\n          if (chunk[pos - 1] === 0x0a) {\n            pos--;\n\n            if (pos >= groupstart && chunk[pos - 1] === 0x0d) {\n              pos--;\n            }\n          }\n        }\n\n        if (group.type !== 'none' && group.type !== 'node' && pos > groupstart) {\n          // we have a leftover data/body chunk to push out\n          group.value = chunk.slice(groupstart, pos);\n\n          if (group.value && group.value.length) {\n            _this2.push(group);\n\n            group = {\n              type: 'none'\n            };\n          }\n        }\n\n        if (pos < chunk.length) {\n          if (_this2.line) {\n            _this2.line = Buffer.concat([_this2.line, chunk.slice(pos)]);\n          } else {\n            _this2.line = chunk.slice(pos);\n          }\n        }\n\n        callback();\n      };\n\n      setImmediate(iterateData);\n    }\n  }, {\n    key: \"_flush\",\n    value: function _flush(callback) {\n      var _this3 = this;\n\n      if (this.errored) {\n        return callback();\n      }\n\n      this.processLine(false, true, function (err, data) {\n        if (err) {\n          return setImmediate(function () {\n            return callback(err);\n          });\n        }\n\n        if (data && (data.type === 'node' || data.value && data.value.length)) {\n          _this3.push(data);\n        }\n\n        callback();\n      });\n    }\n  }, {\n    key: \"compareBoundary\",\n    value: function compareBoundary(line, startpos, boundary) {\n      // --{boundary}\\r\\n or --{boundary}--\\r\\n\n      if (line.length < boundary.length + 3 + startpos || line.length > boundary.length + 6 + startpos) {\n        return false;\n      }\n\n      for (var i = 0; i < boundary.length; i++) {\n        if (line[i + 2 + startpos] !== boundary[i]) {\n          return false;\n        }\n      }\n\n      var pos = 0;\n\n      for (var _i = boundary.length + 2 + startpos; _i < line.length; _i++) {\n        var c = line[_i];\n\n        if (pos === 0 && (c === 0x0d || c === 0x0a)) {\n          // 1: next node\n          return 1;\n        }\n\n        if (pos === 0 && c !== 0x2d) {\n          // expecting \"-\"\n          return false;\n        }\n\n        if (pos === 1 && c !== 0x2d) {\n          // expecting \"-\"\n          return false;\n        }\n\n        if (pos === 2 && c !== 0x0d && c !== 0x0a) {\n          // expecting line terminator, either <CR> or <LF>\n          return false;\n        }\n\n        if (pos === 3 && c !== 0x0a) {\n          // expecting line terminator <LF>\n          return false;\n        }\n\n        pos++;\n      } // 2: multipart end\n\n\n      return 2;\n    }\n  }, {\n    key: \"checkBoundary\",\n    value: function checkBoundary(line) {\n      var startpos = 0;\n\n      if (line.length >= 1 && (line[0] === 0x0d || line[0] === 0x0a)) {\n        startpos++;\n\n        if (line.length >= 2 && (line[0] === 0x0d || line[1] === 0x0a)) {\n          startpos++;\n        }\n      }\n\n      if (line.length < 4 || line[startpos] !== 0x2d || line[startpos + 1] !== 0x2d) {\n        // defnitely not a boundary\n        return false;\n      }\n\n      var boundary;\n\n      if (this.node._boundary && (boundary = this.compareBoundary(line, startpos, this.node._boundary))) {\n        // 1: next child\n        // 2: multipart end\n        return boundary;\n      }\n\n      if (this.node._parentBoundary && (boundary = this.compareBoundary(line, startpos, this.node._parentBoundary))) {\n        // 3: next sibling\n        // 4: parent end\n        return boundary + 2;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"processLine\",\n    value: function processLine(line, final, next) {\n      var flush = false;\n\n      if (this.line && line) {\n        line = Buffer.concat([this.line, line]);\n        this.line = false;\n      } else if (this.line && !line) {\n        line = this.line;\n        this.line = false;\n      }\n\n      if (!line) {\n        line = Buffer.alloc(0);\n      }\n\n      if (this.nodeCounter > this.maxChildNodes) {\n        var err = new Error('Max allowed child nodes exceeded');\n        err.code = 'EMAXLEN';\n        return next(err);\n      } // we check boundary outside the HEAD/BODY scope as it may appear anywhere\n\n\n      var boundary = this.checkBoundary(line);\n\n      if (boundary) {\n        // reached boundary, switch context\n        switch (boundary) {\n          case 1:\n            // next child\n            this.newNode(this.node);\n            flush = true;\n            break;\n\n          case 2:\n            // reached end of children, keep current node\n            break;\n\n          case 3:\n            {\n              // next sibling\n              var parentNode = this.node.parentNode;\n\n              if (parentNode && parentNode.contentType === 'message/rfc822') {\n                // special case where immediate parent is an inline message block\n                // move up another step\n                parentNode = parentNode.parentNode;\n              }\n\n              this.newNode(parentNode);\n              flush = true;\n              break;\n            }\n\n          case 4:\n            // special case when boundary close a node with only header.\n            if (this.node && this.node._headerlen && !this.node.headers) {\n              this.node.parseHeaders();\n              this.push(this.node);\n            } // move up\n\n\n            if (this.tree.length) {\n              this.node = this.tree.pop();\n            }\n\n            this.state = BODY;\n            break;\n        }\n\n        return next(null, {\n          node: this.node,\n          type: 'data',\n          value: line\n        }, flush);\n      }\n\n      switch (this.state) {\n        case HEAD:\n          {\n            this.node.addHeaderChunk(line);\n\n            if (this.node._headerlen > this.maxHeadSize) {\n              var _err = new Error('Max header size for a MIME node exceeded');\n\n              _err.code = 'EMAXLEN';\n              return next(_err);\n            }\n\n            if (final || line.length === 1 && line[0] === 0x0a || line.length === 2 && line[0] === 0x0d && line[1] === 0x0a) {\n              var currentNode = this.node;\n              currentNode.parseHeaders(); // if the content is attached message then just continue\n\n              if (currentNode.contentType === 'message/rfc822' && !this.config.ignoreEmbedded && (!currentNode.encoding || ['7bit', '8bit', 'binary'].includes(currentNode.encoding)) && currentNode.disposition !== 'attachment') {\n                currentNode.messageNode = true;\n                this.newNode(currentNode);\n\n                if (currentNode.parentNode) {\n                  this.node._parentBoundary = currentNode.parentNode._boundary;\n                }\n              } else {\n                if (currentNode.contentType === 'message/rfc822') {\n                  currentNode.messageNode = false;\n                }\n\n                this.state = BODY;\n\n                if (currentNode.multipart && currentNode._boundary) {\n                  this.tree.push(currentNode);\n                }\n              }\n\n              return next(null, currentNode, flush);\n            }\n\n            return next();\n          }\n\n        case BODY:\n          {\n            return next(null, {\n              node: this.node,\n              type: this.node.multipart ? 'data' : 'body',\n              value: line\n            }, flush);\n          }\n      }\n\n      next(null, false);\n    }\n  }, {\n    key: \"newNode\",\n    value: function newNode(parent) {\n      this.node = new MimeNode(parent || false, this.config);\n      this.state = HEAD;\n      this.nodeCounter++;\n    }\n  }]);\n\n  return MessageSplitter;\n}(Transform);\n\nmodule.exports = MessageSplitter;","map":null,"metadata":{},"sourceType":"script"}