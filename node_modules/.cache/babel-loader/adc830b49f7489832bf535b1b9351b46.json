{"ast":null,"code":"'use strict';\n\nconst Headers = require('./headers');\n\nconst libmime = require('libmime');\n\nconst libqp = require('libqp');\n\nconst libbase64 = require('libbase64');\n\nconst PassThrough = require('stream').PassThrough;\n\nclass MimeNode {\n  constructor(parentNode, config) {\n    this.type = 'node';\n    this.root = !parentNode;\n    this.parentNode = parentNode;\n    this._parentBoundary = this.parentNode && this.parentNode._boundary;\n    this._headersLines = [];\n    this._headerlen = 0;\n    this._parsedContentType = false;\n    this._boundary = false;\n    this.multipart = false;\n    this.encoding = false;\n    this.headers = false;\n    this.contentType = false;\n    this.flowed = false;\n    this.delSp = false;\n    this.config = config || {};\n    this.libmime = new libmime.Libmime({\n      Iconv: this.config.Iconv\n    });\n    this.parentPartNumber = parentNode && this.partNr || [];\n    this.partNr = false; // resolved later\n\n    this.childPartNumbers = 0;\n  }\n\n  getPartNr(provided) {\n    if (provided) {\n      return [].concat(this.partNr || []).filter(nr => !isNaN(nr)).concat(provided);\n    }\n\n    let childPartNr = ++this.childPartNumbers;\n    return [].concat(this.partNr || []).filter(nr => !isNaN(nr)).concat(childPartNr);\n  }\n\n  addHeaderChunk(line) {\n    if (!line) {\n      return;\n    }\n\n    this._headersLines.push(line);\n\n    this._headerlen += line.length;\n  }\n\n  parseHeaders() {\n    if (this.headers) {\n      return;\n    }\n\n    this.headers = new Headers(Buffer.concat(this._headersLines, this._headerlen), this.config);\n    this._parsedContentType = this.libmime.parseHeaderValue(this.headers.getFirst('Content-Type'));\n    this._parsedContentDisposition = this.libmime.parseHeaderValue(this.headers.getFirst('Content-Disposition'));\n    this.encoding = this.headers.getFirst('Content-Transfer-Encoding').replace(/\\(.*\\)/g, '').toLowerCase().trim();\n    this.contentType = (this._parsedContentType.value || '').toLowerCase().trim() || false;\n    this.charset = this._parsedContentType.params.charset || false;\n    this.disposition = (this._parsedContentDisposition.value || '').toLowerCase().trim() || false; // fix invalidly encoded disposition values\n\n    if (this.disposition) {\n      try {\n        this.disposition = this.libmime.decodeWords(this.disposition);\n      } catch (E) {// failed to parse disposition, keep as is (most probably an unknown charset is used)\n      }\n    }\n\n    this.filename = this._parsedContentDisposition.params.filename || this._parsedContentType.params.name || false;\n\n    if (this._parsedContentType.params.format && this._parsedContentType.params.format.toLowerCase().trim() === 'flowed') {\n      this.flowed = true;\n\n      if (this._parsedContentType.params.delsp && this._parsedContentType.params.delsp.toLowerCase().trim() === 'yes') {\n        this.delSp = true;\n      }\n    }\n\n    if (this.filename) {\n      try {\n        this.filename = this.libmime.decodeWords(this.filename);\n      } catch (E) {// failed to parse filename, keep as is (most probably an unknown charset is used)\n      }\n    }\n\n    this.multipart = this.contentType && this.contentType.substr(0, this.contentType.indexOf('/')) === 'multipart' && this.contentType.substr(this.contentType.indexOf('/') + 1) || false;\n    this._boundary = this._parsedContentType.params.boundary && Buffer.from(this._parsedContentType.params.boundary) || false;\n    this.rfc822 = this.contentType === 'message/rfc822';\n\n    if (!this.parentNode || this.parentNode.rfc822) {\n      this.partNr = this.parentNode ? this.parentNode.getPartNr('TEXT') : ['TEXT'];\n    } else {\n      this.partNr = this.parentNode ? this.parentNode.getPartNr() : [];\n    }\n  }\n\n  getHeaders() {\n    if (!this.headers) {\n      this.parseHeaders();\n    }\n\n    return this.headers.build();\n  }\n\n  setContentType(contentType) {\n    if (!this.headers) {\n      this.parseHeaders();\n    }\n\n    contentType = (contentType || '').toLowerCase().trim();\n\n    if (contentType) {\n      this._parsedContentType.value = contentType;\n    }\n\n    if (!this.flowed && this._parsedContentType.params.format) {\n      delete this._parsedContentType.params.format;\n    }\n\n    if (!this.delSp && this._parsedContentType.params.delsp) {\n      delete this._parsedContentType.params.delsp;\n    }\n\n    this.headers.update('Content-Type', this.libmime.buildHeaderValue(this._parsedContentType));\n  }\n\n  setCharset(charset) {\n    if (!this.headers) {\n      this.parseHeaders();\n    }\n\n    charset = (charset || '').toLowerCase().trim();\n\n    if (charset === 'ascii') {\n      charset = '';\n    }\n\n    if (!charset) {\n      if (!this._parsedContentType.value) {\n        // nothing to set or update\n        return;\n      }\n\n      delete this._parsedContentType.params.charset;\n    } else {\n      this._parsedContentType.params.charset = charset;\n    }\n\n    if (!this._parsedContentType.value) {\n      this._parsedContentType.value = 'text/plain';\n    }\n\n    this.headers.update('Content-Type', this.libmime.buildHeaderValue(this._parsedContentType));\n  }\n\n  setFilename(filename) {\n    if (!this.headers) {\n      this.parseHeaders();\n    }\n\n    this.filename = (filename || '').toLowerCase().trim();\n\n    if (this._parsedContentType.params.name) {\n      delete this._parsedContentType.params.name;\n      this.headers.update('Content-Type', this.libmime.buildHeaderValue(this._parsedContentType));\n    }\n\n    if (!this.filename) {\n      if (!this._parsedContentDisposition.value) {\n        // nothing to set or update\n        return;\n      }\n\n      delete this._parsedContentDisposition.params.filename;\n    } else {\n      this._parsedContentDisposition.params.filename = this.filename;\n    }\n\n    if (!this._parsedContentDisposition.value) {\n      this._parsedContentDisposition.value = 'attachment';\n    }\n\n    this.headers.update('Content-Disposition', this.libmime.buildHeaderValue(this._parsedContentDisposition));\n  }\n\n  getDecoder() {\n    if (!this.headers) {\n      this.parseHeaders();\n    }\n\n    switch (this.encoding) {\n      case 'base64':\n        return new libbase64.Decoder();\n\n      case 'quoted-printable':\n        return new libqp.Decoder();\n\n      default:\n        return new PassThrough();\n    }\n  }\n\n  getEncoder(encoding) {\n    if (!this.headers) {\n      this.parseHeaders();\n    }\n\n    encoding = (encoding || '').toString().toLowerCase().trim();\n\n    if (encoding && encoding !== this.encoding) {\n      this.headers.update('Content-Transfer-Encoding', encoding);\n    } else {\n      encoding = this.encoding;\n    }\n\n    switch (encoding) {\n      case 'base64':\n        return new libbase64.Encoder();\n\n      case 'quoted-printable':\n        return new libqp.Encoder();\n\n      default:\n        return new PassThrough();\n    }\n  }\n\n}\n\nmodule.exports = MimeNode;","map":null,"metadata":{},"sourceType":"script"}