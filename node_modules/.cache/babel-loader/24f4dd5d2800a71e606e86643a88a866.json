{"ast":null,"code":"/* eslint no-control-regex: 0, no-div-regex: 0, quotes: 0 */\n'use strict';\n\nconst libcharset = require('./charset');\n\nconst libbase64 = require('libbase64');\n\nconst libqp = require('libqp');\n\nconst mimetypes = require('./mimetypes');\n\nconst STAGE_KEY = 0x1001;\nconst STAGE_VALUE = 0x1002;\n\nclass Libmime {\n  constructor(config) {\n    this.config = config || {};\n  }\n  /**\n   * Checks if a value is plaintext string (uses only printable 7bit chars)\n   *\n   * @param {String} value String to be tested\n   * @returns {Boolean} true if it is a plaintext string\n   */\n\n\n  isPlainText(value) {\n    if (typeof value !== 'string' || /[\\x00-\\x08\\x0b\\x0c\\x0e-\\x1f\\u0080-\\uFFFF]/.test(value)) {\n      return false;\n    } else {\n      return true;\n    }\n  }\n  /**\n   * Checks if a multi line string containes lines longer than the selected value.\n   *\n   * Useful when detecting if a mail message needs any processing at all â€“\n   * if only plaintext characters are used and lines are short, then there is\n   * no need to encode the values in any way. If the value is plaintext but has\n   * longer lines then allowed, then use format=flowed\n   *\n   * @param {Number} lineLength Max line length to check for\n   * @returns {Boolean} Returns true if there is at least one line longer than lineLength chars\n   */\n\n\n  hasLongerLines(str, lineLength) {\n    return new RegExp('^.{' + (lineLength + 1) + ',}', 'm').test(str);\n  }\n  /**\n   * Decodes a string from a format=flowed soft wrapping.\n   *\n   * @param {String} str Plaintext string with format=flowed to decode\n   * @param {Boolean} [delSp] If true, delete leading spaces (delsp=yes)\n   * @return {String} Mime decoded string\n   */\n\n\n  decodeFlowed(str, delSp) {\n    str = (str || '').toString();\n    return str.split(/\\r?\\n/) // remove soft linebreaks\n    // soft linebreaks are added after space symbols\n    .reduce((previousValue, currentValue) => {\n      if (/ $/.test(previousValue) && !/(^|\\n)-- $/.test(previousValue)) {\n        if (delSp) {\n          // delsp adds space to text to be able to fold it\n          // these spaces can be removed once the text is unfolded\n          return previousValue.slice(0, -1) + currentValue;\n        } else {\n          return previousValue + currentValue;\n        }\n      } else {\n        return previousValue + '\\n' + currentValue;\n      }\n    }) // remove whitespace stuffing\n    // http://tools.ietf.org/html/rfc3676#section-4.4\n    .replace(/^ /gm, '');\n  }\n  /**\n   * Adds soft line breaks to content marked with format=flowed to\n   * ensure that no line in the message is never longer than lineLength\n   *\n   * @param {String} str Plaintext string that requires wrapping\n   * @param {Number} [lineLength=76] Maximum length of a line\n   * @return {String} String with forced line breaks\n   */\n\n\n  encodeFlowed(str, lineLength) {\n    lineLength = lineLength || 76;\n    let flowed = [];\n    str.split(/\\r?\\n/).forEach(line => {\n      flowed.push(this.foldLines(line // space stuffing http://tools.ietf.org/html/rfc3676#section-4.2\n      .replace(/^( |From|>)/gim, ' $1'), lineLength, true));\n    });\n    return flowed.join('\\r\\n');\n  }\n  /**\n   * Encodes a string or an Buffer to an UTF-8 MIME Word (rfc2047)\n   *\n   * @param {String|Buffer} data String to be encoded\n   * @param {String} mimeWordEncoding='Q' Encoding for the mime word, either Q or B\n   * @param {Number} [maxLength=0] If set, split mime words into several chunks if needed\n   * @return {String} Single or several mime words joined together\n   */\n\n\n  encodeWord(data, mimeWordEncoding, maxLength) {\n    mimeWordEncoding = (mimeWordEncoding || 'Q').toString().toUpperCase().trim().charAt(0);\n    maxLength = maxLength || 0;\n    let encodedStr;\n    let toCharset = 'UTF-8';\n\n    if (maxLength && maxLength > 7 + toCharset.length) {\n      maxLength -= 7 + toCharset.length;\n    }\n\n    if (mimeWordEncoding === 'Q') {\n      // https://tools.ietf.org/html/rfc2047#section-5 rule (3)\n      encodedStr = libqp.encode(data).replace(/[^a-z0-9!*+\\-/=]/gi, chr => {\n        let ord = chr.charCodeAt(0).toString(16).toUpperCase();\n\n        if (chr === ' ') {\n          return '_';\n        } else {\n          return '=' + (ord.length === 1 ? '0' + ord : ord);\n        }\n      });\n    } else if (mimeWordEncoding === 'B') {\n      encodedStr = typeof data === 'string' ? data : libbase64.encode(data);\n      maxLength = maxLength ? Math.max(3, (maxLength - maxLength % 4) / 4 * 3) : 0;\n    }\n\n    if (maxLength && (mimeWordEncoding !== 'B' ? encodedStr : libbase64.encode(data)).length > maxLength) {\n      if (mimeWordEncoding === 'Q') {\n        encodedStr = this.splitMimeEncodedString(encodedStr, maxLength).join('?= =?' + toCharset + '?' + mimeWordEncoding + '?');\n      } else {\n        // RFC2047 6.3 (2) states that encoded-word must include an integral number of characters, so no chopping unicode sequences\n        let parts = [];\n        let lpart = '';\n\n        for (let i = 0, len = encodedStr.length; i < len; i++) {\n          let chr = encodedStr.charAt(i); // check if we can add this character to the existing string\n          // without breaking byte length limit\n\n          if (Buffer.byteLength(lpart + chr) <= maxLength || i === 0) {\n            lpart += chr;\n          } else {\n            // we hit the length limit, so push the existing string and start over\n            parts.push(libbase64.encode(lpart));\n            lpart = chr;\n          }\n        }\n\n        if (lpart) {\n          parts.push(libbase64.encode(lpart));\n        }\n\n        if (parts.length > 1) {\n          encodedStr = parts.join('?= =?' + toCharset + '?' + mimeWordEncoding + '?');\n        } else {\n          encodedStr = parts.join('');\n        }\n      }\n    } else if (mimeWordEncoding === 'B') {\n      encodedStr = libbase64.encode(data);\n    }\n\n    return '=?' + toCharset + '?' + mimeWordEncoding + '?' + encodedStr + (encodedStr.substr(-2) === '?=' ? '' : '?=');\n  }\n  /**\n   * Decode a complete mime word encoded string\n   *\n   * @param {String} str Mime word encoded string\n   * @return {String} Decoded unicode string\n   */\n\n\n  decodeWord(charset, encoding, str) {\n    // RFC2231 added language tag to the encoding\n    // see: https://tools.ietf.org/html/rfc2231#section-5\n    // this implementation silently ignores this tag\n    let splitPos = charset.indexOf('*');\n\n    if (splitPos >= 0) {\n      charset = charset.substr(0, splitPos);\n    }\n\n    charset = libcharset.normalizeCharset(charset);\n    encoding = encoding.toUpperCase();\n\n    if (encoding === 'Q') {\n      str = str // remove spaces between = and hex char, this might indicate invalidly applied line splitting\n      .replace(/=\\s+([0-9a-fA-F])/g, '=$1') // convert all underscores to spaces\n      .replace(/[_\\s]/g, ' ');\n      let buf = Buffer.from(str);\n      let bytes = [];\n\n      for (let i = 0, len = buf.length; i < len; i++) {\n        let c = buf[i];\n\n        if (i <= len - 2 && c === 0x3d\n        /* = */\n        ) {\n            let c1 = this.getHex(buf[i + 1]);\n            let c2 = this.getHex(buf[i + 2]);\n\n            if (c1 && c2) {\n              let c = parseInt(c1 + c2, 16);\n              bytes.push(c);\n              i += 2;\n              continue;\n            }\n          }\n\n        bytes.push(c);\n      }\n\n      str = Buffer.from(bytes);\n    } else if (encoding === 'B') {\n      str = Buffer.concat(str.split('=').filter(s => s !== '') // filter empty string\n      .map(str => Buffer.from(str, 'base64')));\n    } else {\n      // keep as is, convert Buffer to unicode string, assume utf8\n      str = Buffer.from(str);\n    }\n\n    return libcharset.decode(str, charset);\n  }\n  /**\n   * Finds word sequences with non ascii text and converts these to mime words\n   *\n   * @param {String|Buffer} data String to be encoded\n   * @param {String} mimeWordEncoding='Q' Encoding for the mime word, either Q or B\n   * @param {Number} [maxLength=0] If set, split mime words into several chunks if needed\n   * @param {String} [fromCharset='UTF-8'] Source sharacter set\n   * @return {String} String with possible mime words\n   */\n\n\n  encodeWords(data, mimeWordEncoding, maxLength, fromCharset) {\n    if (!fromCharset && typeof maxLength === 'string' && !maxLength.match(/^[0-9]+$/)) {\n      fromCharset = maxLength;\n      maxLength = undefined;\n    }\n\n    maxLength = maxLength || 0;\n    let decodedValue = libcharset.decode(libcharset.convert(data || '', fromCharset));\n    let encodedValue;\n    let firstMatch = decodedValue.match(/(?:^|\\s)([^\\s]*[\\u0080-\\uFFFF])/);\n\n    if (!firstMatch) {\n      return decodedValue;\n    }\n\n    let lastMatch = decodedValue.match(/([\\u0080-\\uFFFF][^\\s]*)[^\\u0080-\\uFFFF]*$/);\n\n    if (!lastMatch) {\n      // should not happen\n      return decodedValue;\n    }\n\n    let startIndex = firstMatch.index + (firstMatch[0].match(/[^\\s]/) || {\n      index: 0\n    }).index;\n    let endIndex = lastMatch.index + (lastMatch[1] || '').length;\n    encodedValue = (startIndex ? decodedValue.substr(0, startIndex) : '') + this.encodeWord(decodedValue.substring(startIndex, endIndex), mimeWordEncoding || 'Q', maxLength) + (endIndex < decodedValue.length ? decodedValue.substr(endIndex) : '');\n    return encodedValue;\n  }\n  /**\n   * Decode a string that might include one or several mime words\n   *\n   * @param {String} str String including some mime words that will be encoded\n   * @return {String} Decoded unicode string\n   */\n\n\n  decodeWords(str) {\n    return (str || '').toString() // find base64 words that can be joined\n    .replace(/(=\\?([^?]+)\\?[Bb]\\?[^?]*\\?=)\\s*(?==\\?([^?]+)\\?[Bb]\\?[^?]*\\?=)/g, (match, left, chLeft, chRight) => {\n      // only mark b64 chunks to be joined if charsets match\n      if (libcharset.normalizeCharset(chLeft || '') === libcharset.normalizeCharset(chRight || '')) {\n        // set a joiner marker\n        return left + '__\\x00JOIN\\x00__';\n      }\n\n      return match;\n    }) // find QP words that can be joined\n    .replace(/(=\\?([^?]+)\\?[Qq]\\?[^?]*\\?=)\\s*(?==\\?([^?]+)\\?[Qq]\\?[^?]*\\?=)/g, (match, left, chLeft, chRight) => {\n      // only mark QP chunks to be joined if charsets match\n      if (libcharset.normalizeCharset(chLeft || '') === libcharset.normalizeCharset(chRight || '')) {\n        // set a joiner marker\n        return left + '__\\x00JOIN\\x00__';\n      }\n\n      return match;\n    }) // join base64 encoded words\n    .replace(/(\\?=)?__\\x00JOIN\\x00__(=\\?([^?]+)\\?[QqBb]\\?)?/g, '') // remove spaces between mime encoded words\n    .replace(/(=\\?[^?]+\\?[QqBb]\\?[^?]*\\?=)\\s+(?==\\?[^?]+\\?[QqBb]\\?[^?]*\\?=)/g, '$1') // decode words\n    .replace(/=\\?([\\w_\\-*]+)\\?([QqBb])\\?([^?]*)\\?=/g, (m, charset, encoding, text) => this.decodeWord(charset, encoding, text));\n  }\n\n  getHex(c) {\n    if (c >= 0x30\n    /* 0 */\n    && c <= 0x39 ||\n    /* 9 */\n    c >= 0x61\n    /* a */\n    && c <= 0x66\n    /* f */\n    || c >= 0x41\n    /* A */\n    && c <= 0x46\n    /* F */\n    ) {\n        return String.fromCharCode(c);\n      }\n\n    return false;\n  }\n  /**\n   * Splits a string by :\n   * The result is not mime word decoded, you need to do your own decoding based\n   * on the rules for the specific header key\n   *\n   * @param {String} headerLine Single header line, might include linebreaks as well if folded\n   * @return {Object} And object of {key, value}\n   */\n\n\n  decodeHeader(headerLine) {\n    let line = (headerLine || '').toString().replace(/(?:\\r?\\n|\\r)[ \\t]*/g, ' ').trim(),\n        match = line.match(/^\\s*([^:]+):(.*)$/),\n        key = (match && match[1] || '').trim().toLowerCase(),\n        value = (match && match[2] || '').trim();\n    return {\n      key,\n      value\n    };\n  }\n  /**\n   * Parses a block of header lines. Does not decode mime words as every\n   * header might have its own rules (eg. formatted email addresses and such)\n   *\n   * @param {String} headers Headers string\n   * @return {Object} An object of headers, where header keys are object keys. NB! Several values with the same key make up an Array\n   */\n\n\n  decodeHeaders(headers) {\n    let lines = headers.split(/\\r?\\n|\\r/),\n        headersObj = {},\n        header,\n        i,\n        len;\n\n    for (i = lines.length - 1; i >= 0; i--) {\n      if (i && lines[i].match(/^\\s/)) {\n        lines[i - 1] += '\\r\\n' + lines[i];\n        lines.splice(i, 1);\n      }\n    }\n\n    for (i = 0, len = lines.length; i < len; i++) {\n      header = this.decodeHeader(lines[i]);\n\n      if (!headersObj[header.key]) {\n        headersObj[header.key] = [header.value];\n      } else {\n        headersObj[header.key].push(header.value);\n      }\n    }\n\n    return headersObj;\n  }\n  /**\n   * Joins parsed header value together as 'value; param1=value1; param2=value2'\n   * PS: We are following RFC 822 for the list of special characters that we need to keep in quotes.\n   *      Refer: https://www.w3.org/Protocols/rfc1341/4_Content-Type.html\n   * @param {Object} structured Parsed header value\n   * @return {String} joined header value\n   */\n\n\n  buildHeaderValue(structured) {\n    let paramsArray = [];\n    Object.keys(structured.params || {}).forEach(param => {\n      // filename might include unicode characters so it is a special case\n      let value = structured.params[param];\n\n      if (!this.isPlainText(value) || value.length >= 75) {\n        this.buildHeaderParam(param, value, 50).forEach(encodedParam => {\n          if (!/[\\s\"\\\\;:/=(),<>@[\\]?]|^[-']|'$/.test(encodedParam.value) || encodedParam.key.substr(-1) === '*') {\n            paramsArray.push(encodedParam.key + '=' + encodedParam.value);\n          } else {\n            paramsArray.push(encodedParam.key + '=' + JSON.stringify(encodedParam.value));\n          }\n        });\n      } else if (/[\\s'\"\\\\;:/=(),<>@[\\]?]|^-/.test(value)) {\n        paramsArray.push(param + '=' + JSON.stringify(value));\n      } else {\n        paramsArray.push(param + '=' + value);\n      }\n    });\n    return structured.value + (paramsArray.length ? '; ' + paramsArray.join('; ') : '');\n  }\n  /**\n   * Parses a header value with key=value arguments into a structured\n   * object.\n   *\n   *   parseHeaderValue('content-type: text/plain; CHARSET='UTF-8'') ->\n   *   {\n   *     'value': 'text/plain',\n   *     'params': {\n   *       'charset': 'UTF-8'\n   *     }\n   *   }\n   *\n   * @param {String} str Header value\n   * @return {Object} Header value as a parsed structure\n   */\n\n\n  parseHeaderValue(str) {\n    let response = {\n      value: false,\n      params: {}\n    };\n    let key = false;\n    let value = '';\n    let stage = STAGE_VALUE;\n    let quote = false;\n    let escaped = false;\n    let chr;\n\n    for (let i = 0, len = str.length; i < len; i++) {\n      chr = str.charAt(i);\n\n      switch (stage) {\n        case STAGE_KEY:\n          if (chr === '=') {\n            key = value.trim().toLowerCase();\n            stage = STAGE_VALUE;\n            value = '';\n            break;\n          }\n\n          value += chr;\n          break;\n\n        case STAGE_VALUE:\n          if (escaped) {\n            value += chr;\n          } else if (chr === '\\\\') {\n            escaped = true;\n            continue;\n          } else if (quote && chr === quote) {\n            quote = false;\n          } else if (!quote && chr === '\"') {\n            quote = chr;\n          } else if (!quote && chr === ';') {\n            if (key === false) {\n              response.value = value.trim();\n            } else {\n              response.params[key] = value.trim();\n            }\n\n            stage = STAGE_KEY;\n            value = '';\n          } else {\n            value += chr;\n          }\n\n          escaped = false;\n          break;\n      }\n    } // finalize remainder\n\n\n    value = value.trim();\n\n    if (stage === STAGE_VALUE) {\n      if (key === false) {\n        // default value\n        response.value = value;\n      } else {\n        // subkey value\n        response.params[key] = value;\n      }\n    } else if (value) {\n      // treat as key without value, see emptykey:\n      // Header-Key: somevalue; key=value; emptykey\n      response.params[value.toLowerCase()] = '';\n    } // handle parameter value continuations\n    // https://tools.ietf.org/html/rfc2231#section-3\n    // preprocess values\n\n\n    Object.keys(response.params).forEach(key => {\n      let actualKey;\n      let nr;\n      let value;\n      let match = key.match(/\\*((\\d+)\\*?)?$/);\n\n      if (!match) {\n        // nothing to do here, does not seem like a continuation param\n        return;\n      }\n\n      actualKey = key.substr(0, match.index).toLowerCase();\n      nr = Number(match[2]) || 0;\n\n      if (!response.params[actualKey] || typeof response.params[actualKey] !== 'object') {\n        response.params[actualKey] = {\n          charset: false,\n          values: []\n        };\n      }\n\n      value = response.params[key];\n\n      if (nr === 0 && match[0].charAt(match[0].length - 1) === '*' && (match = value.match(/^([^']*)'[^']*'(.*)$/))) {\n        response.params[actualKey].charset = match[1] || 'utf-8';\n        value = match[2];\n      }\n\n      response.params[actualKey].values.push({\n        nr,\n        value\n      }); // remove the old reference\n\n      delete response.params[key];\n    }); // concatenate split rfc2231 strings and convert encoded strings to mime encoded words\n\n    Object.keys(response.params).forEach(key => {\n      let value;\n\n      if (response.params[key] && Array.isArray(response.params[key].values)) {\n        value = response.params[key].values.sort((a, b) => a.nr - b.nr).map(val => val && val.value || '').join('');\n\n        if (response.params[key].charset) {\n          // convert \"%AB\" to \"=?charset?Q?=AB?=\" and then to unicode\n          response.params[key] = this.decodeWords('=?' + response.params[key].charset + '?Q?' + value // fix invalidly encoded chars\n          .replace(/[=?_\\s]/g, s => {\n            let c = s.charCodeAt(0).toString(16);\n\n            if (s === ' ') {\n              return '_';\n            } else {\n              return '%' + (c.length < 2 ? '0' : '') + c;\n            }\n          }) // change from urlencoding to percent encoding\n          .replace(/%/g, '=') + '?=');\n        } else {\n          response.params[key] = this.decodeWords(value);\n        }\n      }\n    });\n    return response;\n  }\n  /**\n   * Encodes a string or an Buffer to an UTF-8 Parameter Value Continuation encoding (rfc2231)\n   * Useful for splitting long parameter values.\n   *\n   * For example\n   *      title=\"unicode string\"\n   * becomes\n   *     title*0*=utf-8''unicode\n   *     title*1*=%20string\n   *\n   * @param {String|Buffer} data String to be encoded\n   * @param {Number} [maxLength=50] Max length for generated chunks\n   * @param {String} [fromCharset='UTF-8'] Source sharacter set\n   * @return {Array} A list of encoded keys and headers\n   */\n\n\n  buildHeaderParam(key, data, maxLength, fromCharset) {\n    let list = [];\n    let encodedStr = typeof data === 'string' ? data : this.decode(data, fromCharset);\n    let encodedStrArr;\n    let chr, ord;\n    let line;\n    let startPos = 0;\n    let isEncoded = false;\n    let i, len;\n    maxLength = maxLength || 50; // process ascii only text\n\n    if (this.isPlainText(data)) {\n      // check if conversion is even needed\n      if (encodedStr.length <= maxLength) {\n        return [{\n          key,\n          value: encodedStr\n        }];\n      }\n\n      encodedStr = encodedStr.replace(new RegExp('.{' + maxLength + '}', 'g'), str => {\n        list.push({\n          line: str\n        });\n        return '';\n      });\n\n      if (encodedStr) {\n        list.push({\n          line: encodedStr\n        });\n      }\n    } else {\n      if (/[\\uD800-\\uDBFF]/.test(encodedStr)) {\n        // string containts surrogate pairs, so normalize it to an array of bytes\n        encodedStrArr = [];\n\n        for (i = 0, len = encodedStr.length; i < len; i++) {\n          chr = encodedStr.charAt(i);\n          ord = chr.charCodeAt(0);\n\n          if (ord >= 0xd800 && ord <= 0xdbff && i < len - 1) {\n            chr += encodedStr.charAt(i + 1);\n            encodedStrArr.push(chr);\n            i++;\n          } else {\n            encodedStrArr.push(chr);\n          }\n        }\n\n        encodedStr = encodedStrArr;\n      } // first line includes the charset and language info and needs to be encoded\n      // even if it does not contain any unicode characters\n\n\n      line = \"utf-8''\";\n      isEncoded = true;\n      startPos = 0; // process text with unicode or special chars\n\n      for (i = 0, len = encodedStr.length; i < len; i++) {\n        chr = encodedStr[i];\n\n        if (isEncoded) {\n          chr = this.safeEncodeURIComponent(chr);\n        } else {\n          // try to urlencode current char\n          chr = chr === ' ' ? chr : this.safeEncodeURIComponent(chr); // By default it is not required to encode a line, the need\n          // only appears when the string contains unicode or special chars\n          // in this case we start processing the line over and encode all chars\n\n          if (chr !== encodedStr[i]) {\n            // Check if it is even possible to add the encoded char to the line\n            // If not, there is no reason to use this line, just push it to the list\n            // and start a new line with the char that needs encoding\n            if ((this.safeEncodeURIComponent(line) + chr).length >= maxLength) {\n              list.push({\n                line,\n                encoded: isEncoded\n              });\n              line = '';\n              startPos = i - 1;\n            } else {\n              isEncoded = true;\n              i = startPos;\n              line = '';\n              continue;\n            }\n          }\n        } // if the line is already too long, push it to the list and start a new one\n\n\n        if ((line + chr).length >= maxLength) {\n          list.push({\n            line,\n            encoded: isEncoded\n          });\n          line = chr = encodedStr[i] === ' ' ? ' ' : this.safeEncodeURIComponent(encodedStr[i]);\n\n          if (chr === encodedStr[i]) {\n            isEncoded = false;\n            startPos = i - 1;\n          } else {\n            isEncoded = true;\n          }\n        } else {\n          line += chr;\n        }\n      }\n\n      if (line) {\n        list.push({\n          line,\n          encoded: isEncoded\n        });\n      }\n    }\n\n    return list.map((item, i) => ({\n      // encoded lines: {name}*{part}*\n      // unencoded lines: {name}*{part}\n      // if any line needs to be encoded then the first line (part==0) is always encoded\n      key: key + '*' + i + (item.encoded ? '*' : ''),\n      value: item.line\n    }));\n  }\n  /**\n   * Returns file extension for a content type string. If no suitable extensions\n   * are found, 'bin' is used as the default extension\n   *\n   * @param {String} mimeType Content type to be checked for\n   * @return {String} File extension\n   */\n\n\n  detectExtension(mimeType) {\n    mimeType = (mimeType || '').toString().toLowerCase().replace(/\\s/g, '');\n\n    if (!(mimeType in mimetypes.list)) {\n      return 'bin';\n    }\n\n    if (typeof mimetypes.list[mimeType] === 'string') {\n      return mimetypes.list[mimeType];\n    }\n\n    let mimeParts = mimeType.split('/'); // search for name match\n\n    for (let i = 0, len = mimetypes.list[mimeType].length; i < len; i++) {\n      if (mimeParts[1] === mimetypes.list[mimeType][i]) {\n        return mimetypes.list[mimeType][i];\n      }\n    } // use the first one\n\n\n    return mimetypes.list[mimeType][0] !== '*' ? mimetypes.list[mimeType][0] : 'bin';\n  }\n  /**\n   * Returns content type for a file extension. If no suitable content types\n   * are found, 'application/octet-stream' is used as the default content type\n   *\n   * @param {String} extension Extension to be checked for\n   * @return {String} File extension\n   */\n\n\n  detectMimeType(extension) {\n    extension = (extension || '').toString().toLowerCase().replace(/\\s/g, '').replace(/^\\./g, '').split('.').pop();\n\n    if (!(extension in mimetypes.extensions)) {\n      return 'application/octet-stream';\n    }\n\n    if (typeof mimetypes.extensions[extension] === 'string') {\n      return mimetypes.extensions[extension];\n    }\n\n    let mimeParts; // search for name match\n\n    for (let i = 0, len = mimetypes.extensions[extension].length; i < len; i++) {\n      mimeParts = mimetypes.extensions[extension][i].split('/');\n\n      if (mimeParts[1] === extension) {\n        return mimetypes.extensions[extension][i];\n      }\n    } // use the first one\n\n\n    return mimetypes.extensions[extension][0];\n  }\n  /**\n   * Folds long lines, useful for folding header lines (afterSpace=false) and\n   * flowed text (afterSpace=true)\n   *\n   * @param {String} str String to be folded\n   * @param {Number} [lineLength=76] Maximum length of a line\n   * @param {Boolean} afterSpace If true, leave a space in th end of a line\n   * @return {String} String with folded lines\n   */\n\n\n  foldLines(str, lineLength, afterSpace) {\n    str = (str || '').toString();\n    lineLength = lineLength || 76;\n    let pos = 0,\n        len = str.length,\n        result = '',\n        line,\n        match;\n\n    while (pos < len) {\n      line = str.substr(pos, lineLength);\n\n      if (line.length < lineLength) {\n        result += line;\n        break;\n      }\n\n      if (match = line.match(/^[^\\n\\r]*(\\r?\\n|\\r)/)) {\n        line = match[0];\n        result += line;\n        pos += line.length;\n        continue;\n      } else if ((match = line.match(/(\\s+)[^\\s]*$/)) && match[0].length - (afterSpace ? (match[1] || '').length : 0) < line.length) {\n        line = line.substr(0, line.length - (match[0].length - (afterSpace ? (match[1] || '').length : 0)));\n      } else if (match = str.substr(pos + line.length).match(/^[^\\s]+(\\s*)/)) {\n        line = line + match[0].substr(0, match[0].length - (!afterSpace ? (match[1] || '').length : 0));\n      }\n\n      result += line;\n      pos += line.length;\n\n      if (pos < len) {\n        result += '\\r\\n';\n      }\n    }\n\n    return result;\n  }\n  /**\n   * Splits a mime encoded string. Needed for dividing mime words into smaller chunks\n   *\n   * @param {String} str Mime encoded string to be split up\n   * @param {Number} maxlen Maximum length of characters for one part (minimum 12)\n   * @return {Array} Split string\n   */\n\n\n  splitMimeEncodedString(str, maxlen) {\n    let curLine,\n        match,\n        chr,\n        done,\n        lines = []; // require at least 12 symbols to fit possible 4 octet UTF-8 sequences\n\n    maxlen = Math.max(maxlen || 0, 12);\n\n    while (str.length) {\n      curLine = str.substr(0, maxlen); // move incomplete escaped char back to main\n\n      if (match = curLine.match(/[=][0-9A-F]?$/i)) {\n        curLine = curLine.substr(0, match.index);\n      }\n\n      done = false;\n\n      while (!done) {\n        done = true; // check if not middle of a unicode char sequence\n\n        if (match = str.substr(curLine.length).match(/^[=]([0-9A-F]{2})/i)) {\n          chr = parseInt(match[1], 16); // invalid sequence, move one char back anc recheck\n\n          if (chr < 0xc2 && chr > 0x7f) {\n            curLine = curLine.substr(0, curLine.length - 3);\n            done = false;\n          }\n        }\n      }\n\n      if (curLine.length) {\n        lines.push(curLine);\n      }\n\n      str = str.substr(curLine.length);\n    }\n\n    return lines;\n  }\n\n  encodeURICharComponent(chr) {\n    let res = '';\n    let ord = chr.charCodeAt(0).toString(16).toUpperCase();\n\n    if (ord.length % 2) {\n      ord = '0' + ord;\n    }\n\n    if (ord.length > 2) {\n      for (let i = 0, len = ord.length / 2; i < len; i++) {\n        res += '%' + ord.substr(i, 2);\n      }\n    } else {\n      res += '%' + ord;\n    }\n\n    return res;\n  }\n\n  safeEncodeURIComponent(str) {\n    str = (str || '').toString();\n\n    try {\n      // might throw if we try to encode invalid sequences, eg. partial emoji\n      str = encodeURIComponent(str);\n    } catch (E) {\n      // should never run\n      return str.replace(/[^\\x00-\\x1F *'()<>@,;:\\\\\"[\\]?=\\u007F-\\uFFFF]+/g, '');\n    } // ensure chars that are not handled by encodeURICompent are converted as well\n\n\n    return str.replace(/[\\x00-\\x1F *'()<>@,;:\\\\\"[\\]?=\\u007F-\\uFFFF]/g, chr => this.encodeURICharComponent(chr));\n  }\n\n}\n\nmodule.exports = new Libmime();\nmodule.exports.Libmime = Libmime;","map":null,"metadata":{},"sourceType":"script"}