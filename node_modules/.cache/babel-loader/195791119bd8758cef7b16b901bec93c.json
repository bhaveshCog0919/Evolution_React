{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/bhavik/Downloads/Cognisun/Evolution/Evolution_React/evolution_new/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/bhavik/Downloads/Cognisun/Evolution/Evolution_React/evolution_new/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar libmime = require('libmime');\n/**\n * Class Headers to parse and handle message headers. Headers instance allows to\n * check existing, delete or add new headers\n */\n\n\nvar Headers = /*#__PURE__*/function () {\n  function Headers(headers, config) {\n    _classCallCheck(this, Headers);\n\n    config = config || {};\n\n    if (Array.isArray(headers)) {\n      // already using parsed headers\n      this.changed = true;\n      this.headers = false;\n      this.parsed = true;\n      this.lines = headers;\n    } else {\n      // using original string/buffer headers\n      this.changed = false;\n      this.headers = headers;\n      this.parsed = false;\n      this.lines = false;\n    }\n\n    this.mbox = false;\n    this.http = false;\n    this.libmime = new libmime.Libmime({\n      Iconv: config.Iconv\n    });\n  }\n\n  _createClass(Headers, [{\n    key: \"hasHeader\",\n    value: function hasHeader(key) {\n      if (!this.parsed) {\n        this._parseHeaders();\n      }\n\n      key = this._normalizeHeader(key);\n      return typeof this.lines.find(function (line) {\n        return line.key === key;\n      }) === 'object';\n    }\n  }, {\n    key: \"get\",\n    value: function get(key) {\n      if (!this.parsed) {\n        this._parseHeaders();\n      }\n\n      key = this._normalizeHeader(key);\n      var lines = this.lines.filter(function (line) {\n        return line.key === key;\n      }).map(function (line) {\n        return line.line;\n      });\n      return lines;\n    }\n  }, {\n    key: \"getDecoded\",\n    value: function getDecoded(key) {\n      var _this = this;\n\n      return this.get(key).map(function (line) {\n        return _this.libmime.decodeHeader(line);\n      }).filter(function (line) {\n        return line && line.value;\n      });\n    }\n  }, {\n    key: \"getFirst\",\n    value: function getFirst(key) {\n      if (!this.parsed) {\n        this._parseHeaders();\n      }\n\n      key = this._normalizeHeader(key);\n      var header = this.lines.find(function (line) {\n        return line.key === key;\n      });\n\n      if (!header) {\n        return '';\n      }\n\n      return ((this.libmime.decodeHeader(header.line) || {}).value || '').toString().trim();\n    }\n  }, {\n    key: \"getList\",\n    value: function getList() {\n      if (!this.parsed) {\n        this._parseHeaders();\n      }\n\n      return this.lines;\n    }\n  }, {\n    key: \"add\",\n    value: function add(key, value, index) {\n      if (typeof value === 'undefined') {\n        return;\n      }\n\n      if (typeof value === 'number') {\n        value = value.toString();\n      }\n\n      if (typeof value === 'string') {\n        value = Buffer.from(value);\n      }\n\n      value = value.toString('binary');\n      this.addFormatted(key, this.libmime.foldLines(key + ': ' + value.replace(/\\r?\\n/g, ''), 76, false), index);\n    }\n  }, {\n    key: \"addFormatted\",\n    value: function addFormatted(key, line, index) {\n      if (!this.parsed) {\n        this._parseHeaders();\n      }\n\n      index = index || 0;\n      this.changed = true;\n\n      if (!line) {\n        return;\n      }\n\n      if (typeof line !== 'string') {\n        line = line.toString('binary');\n      }\n\n      var header = {\n        key: this._normalizeHeader(key),\n        line: line\n      };\n\n      if (index < 1) {\n        this.lines.unshift(header);\n      } else if (index >= this.lines.length) {\n        this.lines.push(header);\n      } else {\n        this.lines.splice(index, 0, header);\n      }\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(key) {\n      if (!this.parsed) {\n        this._parseHeaders();\n      }\n\n      key = this._normalizeHeader(key);\n\n      for (var i = this.lines.length - 1; i >= 0; i--) {\n        if (this.lines[i].key === key) {\n          this.changed = true;\n          this.lines.splice(i, 1);\n        }\n      }\n    }\n  }, {\n    key: \"update\",\n    value: function update(key, value, relativeIndex) {\n      if (!this.parsed) {\n        this._parseHeaders();\n      }\n\n      var keyName = key;\n      var index = 0;\n      key = this._normalizeHeader(key);\n      var relativeIndexCount = 0;\n      var relativeMatchFound = false;\n\n      for (var i = this.lines.length - 1; i >= 0; i--) {\n        if (this.lines[i].key === key) {\n          if (relativeIndex && relativeIndex !== relativeIndexCount) {\n            relativeIndexCount++;\n            continue;\n          }\n\n          index = i;\n          this.changed = true;\n          this.lines.splice(i, 1);\n\n          if (relativeIndex) {\n            relativeMatchFound = true;\n            break;\n          }\n        }\n      }\n\n      if (relativeIndex && !relativeMatchFound) return;\n      this.add(keyName, value, index);\n    }\n  }, {\n    key: \"build\",\n    value: function build(lineEnd) {\n      if (!this.changed && !lineEnd) {\n        return typeof this.headers === 'string' ? Buffer.from(this.headers, 'binary') : this.headers;\n      }\n\n      if (!this.parsed) {\n        this._parseHeaders();\n      }\n\n      lineEnd = lineEnd || '\\r\\n';\n      var headers = this.lines.map(function (line) {\n        return line.line.replace(/\\r?\\n/g, lineEnd);\n      }).join(lineEnd) + \"\".concat(lineEnd).concat(lineEnd);\n\n      if (this.mbox) {\n        headers = this.mbox + lineEnd + headers;\n      }\n\n      if (this.http) {\n        headers = this.http + lineEnd + headers;\n      }\n\n      return Buffer.from(headers, 'binary');\n    }\n  }, {\n    key: \"_normalizeHeader\",\n    value: function _normalizeHeader(key) {\n      return (key || '').toLowerCase().trim();\n    }\n  }, {\n    key: \"_parseHeaders\",\n    value: function _parseHeaders() {\n      if (!this.headers) {\n        this.lines = [];\n        this.parsed = true;\n        return;\n      }\n\n      var lines = this.headers.toString('binary').replace(/[\\r\\n]+$/, '').split(/\\r?\\n/);\n\n      for (var i = lines.length - 1; i >= 0; i--) {\n        var chr = lines[i].charAt(0);\n\n        if (i && (chr === ' ' || chr === '\\t')) {\n          lines[i - 1] += '\\r\\n' + lines[i];\n          lines.splice(i, 1);\n        } else {\n          var line = lines[i];\n\n          if (!i && /^From /i.test(line)) {\n            // mbox file\n            this.mbox = line;\n            lines.splice(i, 1);\n            continue;\n          } else if (!i && /^POST /i.test(line)) {\n            // HTTP POST request\n            this.http = line;\n            lines.splice(i, 1);\n            continue;\n          }\n\n          var key = this._normalizeHeader(line.substr(0, line.indexOf(':')));\n\n          lines[i] = {\n            key: key,\n            line: line\n          };\n        }\n      }\n\n      this.lines = lines;\n      this.parsed = true;\n    }\n  }]);\n\n  return Headers;\n}(); // expose to the world\n\n\nmodule.exports = Headers;","map":null,"metadata":{},"sourceType":"script"}